// Code generated by Prisma (prisma@1.21.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  attendanceCycle: (where?: AttendanceCycleWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  directCredit: (where?: DirectCreditWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  eventSyncLog: (where?: EventSyncLogWhereInput) => Promise<boolean>;
  exception: (where?: ExceptionWhereInput) => Promise<boolean>;
  exceptionAuthorization: (
    where?: ExceptionAuthorizationWhereInput
  ) => Promise<boolean>;
  exceptionCancellation: (
    where?: ExceptionCancellationWhereInput
  ) => Promise<boolean>;
  exceptionElimination: (
    where?: ExceptionEliminationWhereInput
  ) => Promise<boolean>;
  exceptionRejection: (
    where?: ExceptionRejectionWhereInput
  ) => Promise<boolean>;
  exceptionSlot: (where?: ExceptionSlotWhereInput) => Promise<boolean>;
  fieldOptionLabel: (where?: FieldOptionLabelWhereInput) => Promise<boolean>;
  holiday: (where?: HolidayWhereInput) => Promise<boolean>;
  schedule: (where?: ScheduleWhereInput) => Promise<boolean>;
  scheduleCategoryConfig: (
    where?: ScheduleCategoryConfigWhereInput
  ) => Promise<boolean>;
  scheduleCredit: (where?: ScheduleCreditWhereInput) => Promise<boolean>;
  scheduleDebit: (where?: ScheduleDebitWhereInput) => Promise<boolean>;
  scheduleOfflineElement: (
    where?: ScheduleOfflineElementWhereInput
  ) => Promise<boolean>;
  scheduleRestlineElement: (
    where?: ScheduleRestlineElementWhereInput
  ) => Promise<boolean>;
  scheduleTimelineElement: (
    where?: ScheduleTimelineElementWhereInput
  ) => Promise<boolean>;
  shift: (where?: ShiftWhereInput) => Promise<boolean>;
  shiftSlot: (where?: ShiftSlotWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userRole: (where?: UserRoleWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attendanceCycle: (
    where: AttendanceCycleWhereUniqueInput
  ) => AttendanceCyclePromise;
  attendanceCycles: (
    args?: {
      where?: AttendanceCycleWhereInput;
      orderBy?: AttendanceCycleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AttendanceCycle>;
  attendanceCyclesConnection: (
    args?: {
      where?: AttendanceCycleWhereInput;
      orderBy?: AttendanceCycleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AttendanceCycleConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  departments: (
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Department>;
  departmentsConnection: (
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DepartmentConnectionPromise;
  directCredit: (where: DirectCreditWhereUniqueInput) => DirectCreditPromise;
  directCredits: (
    args?: {
      where?: DirectCreditWhereInput;
      orderBy?: DirectCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DirectCredit>;
  directCreditsConnection: (
    args?: {
      where?: DirectCreditWhereInput;
      orderBy?: DirectCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DirectCreditConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  employees: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Employee>;
  employeesConnection: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EmployeeConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Event>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnectionPromise;
  eventSyncLog: (where: EventSyncLogWhereUniqueInput) => EventSyncLogPromise;
  eventSyncLogs: (
    args?: {
      where?: EventSyncLogWhereInput;
      orderBy?: EventSyncLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<EventSyncLog>;
  eventSyncLogsConnection: (
    args?: {
      where?: EventSyncLogWhereInput;
      orderBy?: EventSyncLogOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventSyncLogConnectionPromise;
  exception: (where: ExceptionWhereUniqueInput) => ExceptionPromise;
  exceptions: (
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Exception>;
  exceptionsConnection: (
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionConnectionPromise;
  exceptionAuthorization: (
    where: ExceptionAuthorizationWhereUniqueInput
  ) => ExceptionAuthorizationPromise;
  exceptionAuthorizations: (
    args?: {
      where?: ExceptionAuthorizationWhereInput;
      orderBy?: ExceptionAuthorizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionAuthorization>;
  exceptionAuthorizationsConnection: (
    args?: {
      where?: ExceptionAuthorizationWhereInput;
      orderBy?: ExceptionAuthorizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionAuthorizationConnectionPromise;
  exceptionCancellation: (
    where: ExceptionCancellationWhereUniqueInput
  ) => ExceptionCancellationPromise;
  exceptionCancellations: (
    args?: {
      where?: ExceptionCancellationWhereInput;
      orderBy?: ExceptionCancellationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionCancellation>;
  exceptionCancellationsConnection: (
    args?: {
      where?: ExceptionCancellationWhereInput;
      orderBy?: ExceptionCancellationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionCancellationConnectionPromise;
  exceptionElimination: (
    where: ExceptionEliminationWhereUniqueInput
  ) => ExceptionEliminationPromise;
  exceptionEliminations: (
    args?: {
      where?: ExceptionEliminationWhereInput;
      orderBy?: ExceptionEliminationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionElimination>;
  exceptionEliminationsConnection: (
    args?: {
      where?: ExceptionEliminationWhereInput;
      orderBy?: ExceptionEliminationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionEliminationConnectionPromise;
  exceptionRejection: (
    where: ExceptionRejectionWhereUniqueInput
  ) => ExceptionRejectionPromise;
  exceptionRejections: (
    args?: {
      where?: ExceptionRejectionWhereInput;
      orderBy?: ExceptionRejectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionRejection>;
  exceptionRejectionsConnection: (
    args?: {
      where?: ExceptionRejectionWhereInput;
      orderBy?: ExceptionRejectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionRejectionConnectionPromise;
  exceptionSlot: (where: ExceptionSlotWhereUniqueInput) => ExceptionSlotPromise;
  exceptionSlots: (
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionSlot>;
  exceptionSlotsConnection: (
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionSlotConnectionPromise;
  fieldOptionLabel: (
    where: FieldOptionLabelWhereUniqueInput
  ) => FieldOptionLabelPromise;
  fieldOptionLabels: (
    args?: {
      where?: FieldOptionLabelWhereInput;
      orderBy?: FieldOptionLabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FieldOptionLabel>;
  fieldOptionLabelsConnection: (
    args?: {
      where?: FieldOptionLabelWhereInput;
      orderBy?: FieldOptionLabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FieldOptionLabelConnectionPromise;
  holiday: (where: HolidayWhereUniqueInput) => HolidayPromise;
  holidays: (
    args?: {
      where?: HolidayWhereInput;
      orderBy?: HolidayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Holiday>;
  holidaysConnection: (
    args?: {
      where?: HolidayWhereInput;
      orderBy?: HolidayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HolidayConnectionPromise;
  schedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  schedules: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Schedule>;
  schedulesConnection: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleConnectionPromise;
  scheduleCategoryConfig: (
    where: ScheduleCategoryConfigWhereUniqueInput
  ) => ScheduleCategoryConfigPromise;
  scheduleCategoryConfigs: (
    args?: {
      where?: ScheduleCategoryConfigWhereInput;
      orderBy?: ScheduleCategoryConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleCategoryConfig>;
  scheduleCategoryConfigsConnection: (
    args?: {
      where?: ScheduleCategoryConfigWhereInput;
      orderBy?: ScheduleCategoryConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleCategoryConfigConnectionPromise;
  scheduleCredit: (
    where: ScheduleCreditWhereUniqueInput
  ) => ScheduleCreditPromise;
  scheduleCredits: (
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleCredit>;
  scheduleCreditsConnection: (
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleCreditConnectionPromise;
  scheduleDebit: (where: ScheduleDebitWhereUniqueInput) => ScheduleDebitPromise;
  scheduleDebits: (
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleDebit>;
  scheduleDebitsConnection: (
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleDebitConnectionPromise;
  scheduleOfflineElement: (
    where: ScheduleOfflineElementWhereUniqueInput
  ) => ScheduleOfflineElementPromise;
  scheduleOfflineElements: (
    args?: {
      where?: ScheduleOfflineElementWhereInput;
      orderBy?: ScheduleOfflineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleOfflineElement>;
  scheduleOfflineElementsConnection: (
    args?: {
      where?: ScheduleOfflineElementWhereInput;
      orderBy?: ScheduleOfflineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleOfflineElementConnectionPromise;
  scheduleRestlineElement: (
    where: ScheduleRestlineElementWhereUniqueInput
  ) => ScheduleRestlineElementPromise;
  scheduleRestlineElements: (
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleRestlineElement>;
  scheduleRestlineElementsConnection: (
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleRestlineElementConnectionPromise;
  scheduleTimelineElement: (
    where: ScheduleTimelineElementWhereUniqueInput
  ) => ScheduleTimelineElementPromise;
  scheduleTimelineElements: (
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleTimelineElement>;
  scheduleTimelineElementsConnection: (
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleTimelineElementConnectionPromise;
  shift: (where: ShiftWhereUniqueInput) => ShiftPromise;
  shifts: (
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Shift>;
  shiftsConnection: (
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShiftConnectionPromise;
  shiftSlot: (where: ShiftSlotWhereUniqueInput) => ShiftSlotPromise;
  shiftSlots: (
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ShiftSlot>;
  shiftSlotsConnection: (
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShiftSlotConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  userRoles: (
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserRole>;
  userRolesConnection: (
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserRoleConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttendanceCycle: (
    data: AttendanceCycleCreateInput
  ) => AttendanceCyclePromise;
  updateAttendanceCycle: (
    args: {
      data: AttendanceCycleUpdateInput;
      where: AttendanceCycleWhereUniqueInput;
    }
  ) => AttendanceCyclePromise;
  updateManyAttendanceCycles: (
    args: {
      data: AttendanceCycleUpdateManyMutationInput;
      where?: AttendanceCycleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAttendanceCycle: (
    args: {
      where: AttendanceCycleWhereUniqueInput;
      create: AttendanceCycleCreateInput;
      update: AttendanceCycleUpdateInput;
    }
  ) => AttendanceCyclePromise;
  deleteAttendanceCycle: (
    where: AttendanceCycleWhereUniqueInput
  ) => AttendanceCyclePromise;
  deleteManyAttendanceCycles: (
    where?: AttendanceCycleWhereInput
  ) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (
    args: { data: DepartmentUpdateInput; where: DepartmentWhereUniqueInput }
  ) => DepartmentPromise;
  updateManyDepartments: (
    args: {
      data: DepartmentUpdateManyMutationInput;
      where?: DepartmentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDepartment: (
    args: {
      where: DepartmentWhereUniqueInput;
      create: DepartmentCreateInput;
      update: DepartmentUpdateInput;
    }
  ) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createDirectCredit: (data: DirectCreditCreateInput) => DirectCreditPromise;
  updateDirectCredit: (
    args: { data: DirectCreditUpdateInput; where: DirectCreditWhereUniqueInput }
  ) => DirectCreditPromise;
  updateManyDirectCredits: (
    args: {
      data: DirectCreditUpdateManyMutationInput;
      where?: DirectCreditWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDirectCredit: (
    args: {
      where: DirectCreditWhereUniqueInput;
      create: DirectCreditCreateInput;
      update: DirectCreditUpdateInput;
    }
  ) => DirectCreditPromise;
  deleteDirectCredit: (
    where: DirectCreditWhereUniqueInput
  ) => DirectCreditPromise;
  deleteManyDirectCredits: (
    where?: DirectCreditWhereInput
  ) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (
    args: { data: EmployeeUpdateInput; where: EmployeeWhereUniqueInput }
  ) => EmployeePromise;
  updateManyEmployees: (
    args: { data: EmployeeUpdateManyMutationInput; where?: EmployeeWhereInput }
  ) => BatchPayloadPromise;
  upsertEmployee: (
    args: {
      where: EmployeeWhereUniqueInput;
      create: EmployeeCreateInput;
      update: EmployeeUpdateInput;
    }
  ) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => EventPromise;
  updateManyEvents: (
    args: { data: EventUpdateManyMutationInput; where?: EventWhereInput }
  ) => BatchPayloadPromise;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createEventSyncLog: (data: EventSyncLogCreateInput) => EventSyncLogPromise;
  updateEventSyncLog: (
    args: { data: EventSyncLogUpdateInput; where: EventSyncLogWhereUniqueInput }
  ) => EventSyncLogPromise;
  updateManyEventSyncLogs: (
    args: {
      data: EventSyncLogUpdateManyMutationInput;
      where?: EventSyncLogWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertEventSyncLog: (
    args: {
      where: EventSyncLogWhereUniqueInput;
      create: EventSyncLogCreateInput;
      update: EventSyncLogUpdateInput;
    }
  ) => EventSyncLogPromise;
  deleteEventSyncLog: (
    where: EventSyncLogWhereUniqueInput
  ) => EventSyncLogPromise;
  deleteManyEventSyncLogs: (
    where?: EventSyncLogWhereInput
  ) => BatchPayloadPromise;
  createException: (data: ExceptionCreateInput) => ExceptionPromise;
  updateException: (
    args: { data: ExceptionUpdateInput; where: ExceptionWhereUniqueInput }
  ) => ExceptionPromise;
  updateManyExceptions: (
    args: {
      data: ExceptionUpdateManyMutationInput;
      where?: ExceptionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertException: (
    args: {
      where: ExceptionWhereUniqueInput;
      create: ExceptionCreateInput;
      update: ExceptionUpdateInput;
    }
  ) => ExceptionPromise;
  deleteException: (where: ExceptionWhereUniqueInput) => ExceptionPromise;
  deleteManyExceptions: (where?: ExceptionWhereInput) => BatchPayloadPromise;
  createExceptionAuthorization: (
    data: ExceptionAuthorizationCreateInput
  ) => ExceptionAuthorizationPromise;
  updateExceptionAuthorization: (
    args: {
      data: ExceptionAuthorizationUpdateInput;
      where: ExceptionAuthorizationWhereUniqueInput;
    }
  ) => ExceptionAuthorizationPromise;
  updateManyExceptionAuthorizations: (
    args: {
      data: ExceptionAuthorizationUpdateManyMutationInput;
      where?: ExceptionAuthorizationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExceptionAuthorization: (
    args: {
      where: ExceptionAuthorizationWhereUniqueInput;
      create: ExceptionAuthorizationCreateInput;
      update: ExceptionAuthorizationUpdateInput;
    }
  ) => ExceptionAuthorizationPromise;
  deleteExceptionAuthorization: (
    where: ExceptionAuthorizationWhereUniqueInput
  ) => ExceptionAuthorizationPromise;
  deleteManyExceptionAuthorizations: (
    where?: ExceptionAuthorizationWhereInput
  ) => BatchPayloadPromise;
  createExceptionCancellation: (
    data: ExceptionCancellationCreateInput
  ) => ExceptionCancellationPromise;
  updateExceptionCancellation: (
    args: {
      data: ExceptionCancellationUpdateInput;
      where: ExceptionCancellationWhereUniqueInput;
    }
  ) => ExceptionCancellationPromise;
  updateManyExceptionCancellations: (
    args: {
      data: ExceptionCancellationUpdateManyMutationInput;
      where?: ExceptionCancellationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExceptionCancellation: (
    args: {
      where: ExceptionCancellationWhereUniqueInput;
      create: ExceptionCancellationCreateInput;
      update: ExceptionCancellationUpdateInput;
    }
  ) => ExceptionCancellationPromise;
  deleteExceptionCancellation: (
    where: ExceptionCancellationWhereUniqueInput
  ) => ExceptionCancellationPromise;
  deleteManyExceptionCancellations: (
    where?: ExceptionCancellationWhereInput
  ) => BatchPayloadPromise;
  createExceptionElimination: (
    data: ExceptionEliminationCreateInput
  ) => ExceptionEliminationPromise;
  updateExceptionElimination: (
    args: {
      data: ExceptionEliminationUpdateInput;
      where: ExceptionEliminationWhereUniqueInput;
    }
  ) => ExceptionEliminationPromise;
  updateManyExceptionEliminations: (
    args: {
      data: ExceptionEliminationUpdateManyMutationInput;
      where?: ExceptionEliminationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExceptionElimination: (
    args: {
      where: ExceptionEliminationWhereUniqueInput;
      create: ExceptionEliminationCreateInput;
      update: ExceptionEliminationUpdateInput;
    }
  ) => ExceptionEliminationPromise;
  deleteExceptionElimination: (
    where: ExceptionEliminationWhereUniqueInput
  ) => ExceptionEliminationPromise;
  deleteManyExceptionEliminations: (
    where?: ExceptionEliminationWhereInput
  ) => BatchPayloadPromise;
  createExceptionRejection: (
    data: ExceptionRejectionCreateInput
  ) => ExceptionRejectionPromise;
  updateExceptionRejection: (
    args: {
      data: ExceptionRejectionUpdateInput;
      where: ExceptionRejectionWhereUniqueInput;
    }
  ) => ExceptionRejectionPromise;
  updateManyExceptionRejections: (
    args: {
      data: ExceptionRejectionUpdateManyMutationInput;
      where?: ExceptionRejectionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExceptionRejection: (
    args: {
      where: ExceptionRejectionWhereUniqueInput;
      create: ExceptionRejectionCreateInput;
      update: ExceptionRejectionUpdateInput;
    }
  ) => ExceptionRejectionPromise;
  deleteExceptionRejection: (
    where: ExceptionRejectionWhereUniqueInput
  ) => ExceptionRejectionPromise;
  deleteManyExceptionRejections: (
    where?: ExceptionRejectionWhereInput
  ) => BatchPayloadPromise;
  createExceptionSlot: (data: ExceptionSlotCreateInput) => ExceptionSlotPromise;
  updateExceptionSlot: (
    args: {
      data: ExceptionSlotUpdateInput;
      where: ExceptionSlotWhereUniqueInput;
    }
  ) => ExceptionSlotPromise;
  updateManyExceptionSlots: (
    args: {
      data: ExceptionSlotUpdateManyMutationInput;
      where?: ExceptionSlotWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExceptionSlot: (
    args: {
      where: ExceptionSlotWhereUniqueInput;
      create: ExceptionSlotCreateInput;
      update: ExceptionSlotUpdateInput;
    }
  ) => ExceptionSlotPromise;
  deleteExceptionSlot: (
    where: ExceptionSlotWhereUniqueInput
  ) => ExceptionSlotPromise;
  deleteManyExceptionSlots: (
    where?: ExceptionSlotWhereInput
  ) => BatchPayloadPromise;
  createFieldOptionLabel: (
    data: FieldOptionLabelCreateInput
  ) => FieldOptionLabelPromise;
  updateFieldOptionLabel: (
    args: {
      data: FieldOptionLabelUpdateInput;
      where: FieldOptionLabelWhereUniqueInput;
    }
  ) => FieldOptionLabelPromise;
  updateManyFieldOptionLabels: (
    args: {
      data: FieldOptionLabelUpdateManyMutationInput;
      where?: FieldOptionLabelWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFieldOptionLabel: (
    args: {
      where: FieldOptionLabelWhereUniqueInput;
      create: FieldOptionLabelCreateInput;
      update: FieldOptionLabelUpdateInput;
    }
  ) => FieldOptionLabelPromise;
  deleteFieldOptionLabel: (
    where: FieldOptionLabelWhereUniqueInput
  ) => FieldOptionLabelPromise;
  deleteManyFieldOptionLabels: (
    where?: FieldOptionLabelWhereInput
  ) => BatchPayloadPromise;
  createHoliday: (data: HolidayCreateInput) => HolidayPromise;
  updateHoliday: (
    args: { data: HolidayUpdateInput; where: HolidayWhereUniqueInput }
  ) => HolidayPromise;
  updateManyHolidays: (
    args: { data: HolidayUpdateManyMutationInput; where?: HolidayWhereInput }
  ) => BatchPayloadPromise;
  upsertHoliday: (
    args: {
      where: HolidayWhereUniqueInput;
      create: HolidayCreateInput;
      update: HolidayUpdateInput;
    }
  ) => HolidayPromise;
  deleteHoliday: (where: HolidayWhereUniqueInput) => HolidayPromise;
  deleteManyHolidays: (where?: HolidayWhereInput) => BatchPayloadPromise;
  createSchedule: (data: ScheduleCreateInput) => SchedulePromise;
  updateSchedule: (
    args: { data: ScheduleUpdateInput; where: ScheduleWhereUniqueInput }
  ) => SchedulePromise;
  updateManySchedules: (
    args: { data: ScheduleUpdateManyMutationInput; where?: ScheduleWhereInput }
  ) => BatchPayloadPromise;
  upsertSchedule: (
    args: {
      where: ScheduleWhereUniqueInput;
      create: ScheduleCreateInput;
      update: ScheduleUpdateInput;
    }
  ) => SchedulePromise;
  deleteSchedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  deleteManySchedules: (where?: ScheduleWhereInput) => BatchPayloadPromise;
  createScheduleCategoryConfig: (
    data: ScheduleCategoryConfigCreateInput
  ) => ScheduleCategoryConfigPromise;
  updateScheduleCategoryConfig: (
    args: {
      data: ScheduleCategoryConfigUpdateInput;
      where: ScheduleCategoryConfigWhereUniqueInput;
    }
  ) => ScheduleCategoryConfigPromise;
  updateManyScheduleCategoryConfigs: (
    args: {
      data: ScheduleCategoryConfigUpdateManyMutationInput;
      where?: ScheduleCategoryConfigWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleCategoryConfig: (
    args: {
      where: ScheduleCategoryConfigWhereUniqueInput;
      create: ScheduleCategoryConfigCreateInput;
      update: ScheduleCategoryConfigUpdateInput;
    }
  ) => ScheduleCategoryConfigPromise;
  deleteScheduleCategoryConfig: (
    where: ScheduleCategoryConfigWhereUniqueInput
  ) => ScheduleCategoryConfigPromise;
  deleteManyScheduleCategoryConfigs: (
    where?: ScheduleCategoryConfigWhereInput
  ) => BatchPayloadPromise;
  createScheduleCredit: (
    data: ScheduleCreditCreateInput
  ) => ScheduleCreditPromise;
  updateScheduleCredit: (
    args: {
      data: ScheduleCreditUpdateInput;
      where: ScheduleCreditWhereUniqueInput;
    }
  ) => ScheduleCreditPromise;
  updateManyScheduleCredits: (
    args: {
      data: ScheduleCreditUpdateManyMutationInput;
      where?: ScheduleCreditWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleCredit: (
    args: {
      where: ScheduleCreditWhereUniqueInput;
      create: ScheduleCreditCreateInput;
      update: ScheduleCreditUpdateInput;
    }
  ) => ScheduleCreditPromise;
  deleteScheduleCredit: (
    where: ScheduleCreditWhereUniqueInput
  ) => ScheduleCreditPromise;
  deleteManyScheduleCredits: (
    where?: ScheduleCreditWhereInput
  ) => BatchPayloadPromise;
  createScheduleDebit: (data: ScheduleDebitCreateInput) => ScheduleDebitPromise;
  updateScheduleDebit: (
    args: {
      data: ScheduleDebitUpdateInput;
      where: ScheduleDebitWhereUniqueInput;
    }
  ) => ScheduleDebitPromise;
  updateManyScheduleDebits: (
    args: {
      data: ScheduleDebitUpdateManyMutationInput;
      where?: ScheduleDebitWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleDebit: (
    args: {
      where: ScheduleDebitWhereUniqueInput;
      create: ScheduleDebitCreateInput;
      update: ScheduleDebitUpdateInput;
    }
  ) => ScheduleDebitPromise;
  deleteScheduleDebit: (
    where: ScheduleDebitWhereUniqueInput
  ) => ScheduleDebitPromise;
  deleteManyScheduleDebits: (
    where?: ScheduleDebitWhereInput
  ) => BatchPayloadPromise;
  createScheduleOfflineElement: (
    data: ScheduleOfflineElementCreateInput
  ) => ScheduleOfflineElementPromise;
  updateScheduleOfflineElement: (
    args: {
      data: ScheduleOfflineElementUpdateInput;
      where: ScheduleOfflineElementWhereUniqueInput;
    }
  ) => ScheduleOfflineElementPromise;
  updateManyScheduleOfflineElements: (
    args: {
      data: ScheduleOfflineElementUpdateManyMutationInput;
      where?: ScheduleOfflineElementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleOfflineElement: (
    args: {
      where: ScheduleOfflineElementWhereUniqueInput;
      create: ScheduleOfflineElementCreateInput;
      update: ScheduleOfflineElementUpdateInput;
    }
  ) => ScheduleOfflineElementPromise;
  deleteScheduleOfflineElement: (
    where: ScheduleOfflineElementWhereUniqueInput
  ) => ScheduleOfflineElementPromise;
  deleteManyScheduleOfflineElements: (
    where?: ScheduleOfflineElementWhereInput
  ) => BatchPayloadPromise;
  createScheduleRestlineElement: (
    data: ScheduleRestlineElementCreateInput
  ) => ScheduleRestlineElementPromise;
  updateScheduleRestlineElement: (
    args: {
      data: ScheduleRestlineElementUpdateInput;
      where: ScheduleRestlineElementWhereUniqueInput;
    }
  ) => ScheduleRestlineElementPromise;
  updateManyScheduleRestlineElements: (
    args: {
      data: ScheduleRestlineElementUpdateManyMutationInput;
      where?: ScheduleRestlineElementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleRestlineElement: (
    args: {
      where: ScheduleRestlineElementWhereUniqueInput;
      create: ScheduleRestlineElementCreateInput;
      update: ScheduleRestlineElementUpdateInput;
    }
  ) => ScheduleRestlineElementPromise;
  deleteScheduleRestlineElement: (
    where: ScheduleRestlineElementWhereUniqueInput
  ) => ScheduleRestlineElementPromise;
  deleteManyScheduleRestlineElements: (
    where?: ScheduleRestlineElementWhereInput
  ) => BatchPayloadPromise;
  createScheduleTimelineElement: (
    data: ScheduleTimelineElementCreateInput
  ) => ScheduleTimelineElementPromise;
  updateScheduleTimelineElement: (
    args: {
      data: ScheduleTimelineElementUpdateInput;
      where: ScheduleTimelineElementWhereUniqueInput;
    }
  ) => ScheduleTimelineElementPromise;
  updateManyScheduleTimelineElements: (
    args: {
      data: ScheduleTimelineElementUpdateManyMutationInput;
      where?: ScheduleTimelineElementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleTimelineElement: (
    args: {
      where: ScheduleTimelineElementWhereUniqueInput;
      create: ScheduleTimelineElementCreateInput;
      update: ScheduleTimelineElementUpdateInput;
    }
  ) => ScheduleTimelineElementPromise;
  deleteScheduleTimelineElement: (
    where: ScheduleTimelineElementWhereUniqueInput
  ) => ScheduleTimelineElementPromise;
  deleteManyScheduleTimelineElements: (
    where?: ScheduleTimelineElementWhereInput
  ) => BatchPayloadPromise;
  createShift: (data: ShiftCreateInput) => ShiftPromise;
  updateShift: (
    args: { data: ShiftUpdateInput; where: ShiftWhereUniqueInput }
  ) => ShiftPromise;
  updateManyShifts: (
    args: { data: ShiftUpdateManyMutationInput; where?: ShiftWhereInput }
  ) => BatchPayloadPromise;
  upsertShift: (
    args: {
      where: ShiftWhereUniqueInput;
      create: ShiftCreateInput;
      update: ShiftUpdateInput;
    }
  ) => ShiftPromise;
  deleteShift: (where: ShiftWhereUniqueInput) => ShiftPromise;
  deleteManyShifts: (where?: ShiftWhereInput) => BatchPayloadPromise;
  createShiftSlot: (data: ShiftSlotCreateInput) => ShiftSlotPromise;
  updateShiftSlot: (
    args: { data: ShiftSlotUpdateInput; where: ShiftSlotWhereUniqueInput }
  ) => ShiftSlotPromise;
  updateManyShiftSlots: (
    args: {
      data: ShiftSlotUpdateManyMutationInput;
      where?: ShiftSlotWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertShiftSlot: (
    args: {
      where: ShiftSlotWhereUniqueInput;
      create: ShiftSlotCreateInput;
      update: ShiftSlotUpdateInput;
    }
  ) => ShiftSlotPromise;
  deleteShiftSlot: (where: ShiftSlotWhereUniqueInput) => ShiftSlotPromise;
  deleteManyShiftSlots: (where?: ShiftSlotWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserRole: (data: UserRoleCreateInput) => UserRolePromise;
  updateUserRole: (
    args: { data: UserRoleUpdateInput; where: UserRoleWhereUniqueInput }
  ) => UserRolePromise;
  updateManyUserRoles: (
    args: { data: UserRoleUpdateManyMutationInput; where?: UserRoleWhereInput }
  ) => BatchPayloadPromise;
  upsertUserRole: (
    args: {
      where: UserRoleWhereUniqueInput;
      create: UserRoleCreateInput;
      update: UserRoleUpdateInput;
    }
  ) => UserRolePromise;
  deleteUserRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  deleteManyUserRoles: (where?: UserRoleWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attendanceCycle: (
    where?: AttendanceCycleSubscriptionWhereInput
  ) => AttendanceCycleSubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  directCredit: (
    where?: DirectCreditSubscriptionWhereInput
  ) => DirectCreditSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  eventSyncLog: (
    where?: EventSyncLogSubscriptionWhereInput
  ) => EventSyncLogSubscriptionPayloadSubscription;
  exception: (
    where?: ExceptionSubscriptionWhereInput
  ) => ExceptionSubscriptionPayloadSubscription;
  exceptionAuthorization: (
    where?: ExceptionAuthorizationSubscriptionWhereInput
  ) => ExceptionAuthorizationSubscriptionPayloadSubscription;
  exceptionCancellation: (
    where?: ExceptionCancellationSubscriptionWhereInput
  ) => ExceptionCancellationSubscriptionPayloadSubscription;
  exceptionElimination: (
    where?: ExceptionEliminationSubscriptionWhereInput
  ) => ExceptionEliminationSubscriptionPayloadSubscription;
  exceptionRejection: (
    where?: ExceptionRejectionSubscriptionWhereInput
  ) => ExceptionRejectionSubscriptionPayloadSubscription;
  exceptionSlot: (
    where?: ExceptionSlotSubscriptionWhereInput
  ) => ExceptionSlotSubscriptionPayloadSubscription;
  fieldOptionLabel: (
    where?: FieldOptionLabelSubscriptionWhereInput
  ) => FieldOptionLabelSubscriptionPayloadSubscription;
  holiday: (
    where?: HolidaySubscriptionWhereInput
  ) => HolidaySubscriptionPayloadSubscription;
  schedule: (
    where?: ScheduleSubscriptionWhereInput
  ) => ScheduleSubscriptionPayloadSubscription;
  scheduleCategoryConfig: (
    where?: ScheduleCategoryConfigSubscriptionWhereInput
  ) => ScheduleCategoryConfigSubscriptionPayloadSubscription;
  scheduleCredit: (
    where?: ScheduleCreditSubscriptionWhereInput
  ) => ScheduleCreditSubscriptionPayloadSubscription;
  scheduleDebit: (
    where?: ScheduleDebitSubscriptionWhereInput
  ) => ScheduleDebitSubscriptionPayloadSubscription;
  scheduleOfflineElement: (
    where?: ScheduleOfflineElementSubscriptionWhereInput
  ) => ScheduleOfflineElementSubscriptionPayloadSubscription;
  scheduleRestlineElement: (
    where?: ScheduleRestlineElementSubscriptionWhereInput
  ) => ScheduleRestlineElementSubscriptionPayloadSubscription;
  scheduleTimelineElement: (
    where?: ScheduleTimelineElementSubscriptionWhereInput
  ) => ScheduleTimelineElementSubscriptionPayloadSubscription;
  shift: (
    where?: ShiftSubscriptionWhereInput
  ) => ShiftSubscriptionPayloadSubscription;
  shiftSlot: (
    where?: ShiftSlotSubscriptionWhereInput
  ) => ShiftSlotSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userRole: (
    where?: UserRoleSubscriptionWhereInput
  ) => UserRoleSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC";

export type ScheduleCreditSourceEnum =
  | "EXCEPTION"
  | "CONCURENT_HOLIDAY"
  | "DIRECT_CREDIT";

export type ScheduleDebitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleOfflineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleCreditOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "sourceType_ASC"
  | "sourceType_DESC"
  | "sourceDate_ASC"
  | "sourceDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleCategory =
  | "SCH_TIME_WORK"
  | "SCH_TIME_EXTRA"
  | "SCH_TIME_MATERNAL"
  | "SCH_TIME_LEAVE"
  | "SCH_REST_LUNCH"
  | "SCH_DAY_OFF"
  | "SCH_DAY_VACATION"
  | "SCH_DAY_HOLIDAY"
  | "SCH_DAY_SICK"
  | "SCH_DAY_PAID"
  | "SCH_DAY_UNPAID";

export type ExceptionSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isPreset_ASC"
  | "isPreset_DESC"
  | "systemScheduleIdentifier_ASC"
  | "systemScheduleIdentifier_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "baseTime_ASC"
  | "baseTime_DESC"
  | "innerBound_ASC"
  | "innerBound_DESC"
  | "outerBound_ASC"
  | "outerBound_DESC";

export type ExceptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC";

export type FieldOptionLabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "field_ASC"
  | "field_DESC"
  | "value_ASC"
  | "value_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExceptionEliminationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type ExceptionAuthorizationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC";

export type SystemScheduleIdentifierEnum =
  | "SYS_SCH_DAYOFF_DAYOFF"
  | "SYS_SCH_VACATION_VACATION"
  | "SYS_SCH_VACATION_DAYOFF"
  | "SYS_SCH_DAYOFF_VACATION"
  | "SYS_SCH_HOLIDAY_HOLIDAY";

export type DirectCreditOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleRestlineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "startEventRequired_ASC"
  | "startEventRequired_DESC"
  | "endEventRequired_ASC"
  | "endEventRequired_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmployeeSexEnum = "F" | "M";

export type ScheduleTimelineCategory =
  | "SCH_TIME_WORK"
  | "SCH_TIME_EXTRA"
  | "SCH_TIME_MATERNAL"
  | "SCH_TIME_LEAVE";

export type EmployeeAFPEnum = "OPTION_1" | "OPTION_2";

export type ScheduleTimelineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "startEventRequired_ASC"
  | "startEventRequired_DESC"
  | "endEventRequired_ASC"
  | "endEventRequired_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleCategoryConfigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "backgroundColor_ASC"
  | "backgroundColor_DESC"
  | "foregroundColor_ASC"
  | "foregroundColor_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleRestlineCategory = "SCH_REST_LUNCH";

export type HolidayOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShiftSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "index_ASC"
  | "index_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExceptionCancellationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC";

export type ScheduleOfflineCategory =
  | "SCH_DAY_OFF"
  | "SCH_DAY_VACATION"
  | "SCH_DAY_HOLIDAY"
  | "SCH_DAY_SICK"
  | "SCH_DAY_PAID"
  | "SCH_DAY_UNPAID";

export type EmployeeDocumentTypeEnum = "CI" | "PASSAPORTE";

export type EmployeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "nameFirst_ASC"
  | "nameFirst_DESC"
  | "nameMiddle_ASC"
  | "nameMiddle_DESC"
  | "namePaternal_ASC"
  | "namePaternal_DESC"
  | "nameMaternal_ASC"
  | "nameMaternal_DESC"
  | "documentType_ASC"
  | "documentType_DESC"
  | "documentNumber_ASC"
  | "documentNumber_DESC"
  | "sex_ASC"
  | "sex_DESC"
  | "dateOfBirth_ASC"
  | "dateOfBirth_DESC"
  | "nationality_ASC"
  | "nationality_DESC"
  | "jubilado_ASC"
  | "jubilado_DESC"
  | "personaConDiscapacidad_ASC"
  | "personaConDiscapacidad_DESC"
  | "tutorPersonaConDiscapacidad_ASC"
  | "tutorPersonaConDiscapacidad_DESC"
  | "cajaDeSalud_ASC"
  | "cajaDeSalud_DESC"
  | "aportaAFP_ASC"
  | "aportaAFP_DESC"
  | "AFP_ASC"
  | "AFP_DESC"
  | "cargo_ASC"
  | "cargo_DESC"
  | "zkTimePin_ASC"
  | "zkTimePin_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "time_ASC"
  | "time_DESC";

export type ExceptionTypeEnum = "MIXED" | "EXTRA_TIME" | "VACATION";

export type ShiftOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC";

export type EmployeeCajaDeSaludEnum =
  | "OPTION_1"
  | "OPTION_2"
  | "OPTION_3"
  | "OPTION_4"
  | "OPTION_5"
  | "OPTION_6"
  | "OPTION_7"
  | "OPTION_8"
  | "OPTION_9";

export type EventSyncLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "from_ASC"
  | "from_DESC"
  | "to_ASC"
  | "to_DESC";

export type ExceptionRejectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC";

export type AttendanceCycleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ShiftSlotUpdateManyInput {
  create?: ShiftSlotCreateInput[] | ShiftSlotCreateInput;
  update?:
    | ShiftSlotUpdateWithWhereUniqueNestedInput[]
    | ShiftSlotUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ShiftSlotUpsertWithWhereUniqueNestedInput[]
    | ShiftSlotUpsertWithWhereUniqueNestedInput;
  delete?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
  connect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
  disconnect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
}

export type AttendanceCycleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateDataInput {
  username?: String;
  password?: String;
  departments?: DepartmentUpdateManyWithoutSupervisorsInput;
  roles?: UserRoleUpdateManyInput;
}

export interface DirectCreditWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  owner?: UserWhereInput;
  employee?: EmployeeWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  credits_every?: ScheduleCreditWhereInput;
  credits_some?: ScheduleCreditWhereInput;
  credits_none?: ScheduleCreditWhereInput;
  AND?: DirectCreditWhereInput[] | DirectCreditWhereInput;
  OR?: DirectCreditWhereInput[] | DirectCreditWhereInput;
  NOT?: DirectCreditWhereInput[] | DirectCreditWhereInput;
}

export interface DepartmentUpdateManyWithoutSupervisorsInput {
  create?:
    | DepartmentCreateWithoutSupervisorsInput[]
    | DepartmentCreateWithoutSupervisorsInput;
  delete?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  disconnect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  update?:
    | DepartmentUpdateWithWhereUniqueWithoutSupervisorsInput[]
    | DepartmentUpdateWithWhereUniqueWithoutSupervisorsInput;
  upsert?:
    | DepartmentUpsertWithWhereUniqueWithoutSupervisorsInput[]
    | DepartmentUpsertWithWhereUniqueWithoutSupervisorsInput;
}

export interface ScheduleDebitWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  employee?: EmployeeWhereInput;
  category?: ScheduleOfflineCategory;
  category_not?: ScheduleOfflineCategory;
  category_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  category_not_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  exception?: ExceptionWhereInput;
  credit?: ScheduleCreditWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: ScheduleDebitWhereInput[] | ScheduleDebitWhereInput;
  OR?: ScheduleDebitWhereInput[] | ScheduleDebitWhereInput;
  NOT?: ScheduleDebitWhereInput[] | ScheduleDebitWhereInput;
}

export interface DepartmentUpdateWithWhereUniqueWithoutSupervisorsInput {
  where: DepartmentWhereUniqueInput;
  data: DepartmentUpdateWithoutSupervisorsDataInput;
}

export interface ExceptionAuthorizationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  exception?: ExceptionWhereInput;
  owner?: UserWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
  OR?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
  NOT?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
}

export interface DepartmentUpdateWithoutSupervisorsDataInput {
  name?: String;
  subordinates?: EmployeeUpdateManyWithoutDepartmentInput;
}

export interface ExceptionEliminationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  exception?: ExceptionWhereInput;
  owner?: UserWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ExceptionEliminationWhereInput[] | ExceptionEliminationWhereInput;
  OR?: ExceptionEliminationWhereInput[] | ExceptionEliminationWhereInput;
  NOT?: ExceptionEliminationWhereInput[] | ExceptionEliminationWhereInput;
}

export interface ExceptionSlotCreateManyInput {
  create?: ExceptionSlotCreateInput[] | ExceptionSlotCreateInput;
  connect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
}

export interface EmployeeCreateOneWithoutEventsInput {
  create?: EmployeeCreateWithoutEventsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ExceptionSlotCreateInput {
  schedule: ScheduleCreateOneInput;
  date: DateTimeInput;
  source1?: ScheduleCreditCreateOneInput;
  source2?: ScheduleCreditCreateOneInput;
}

export interface DepartmentUpsertWithWhereUniqueWithoutSupervisorsInput {
  where: DepartmentWhereUniqueInput;
  update: DepartmentUpdateWithoutSupervisorsDataInput;
  create: DepartmentCreateWithoutSupervisorsInput;
}

export interface ScheduleCreditCreateOneInput {
  create?: ScheduleCreditCreateInput;
  connect?: ScheduleCreditWhereUniqueInput;
}

export interface ExceptionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: ExceptionTypeEnum;
  type_not?: ExceptionTypeEnum;
  type_in?: ExceptionTypeEnum[] | ExceptionTypeEnum;
  type_not_in?: ExceptionTypeEnum[] | ExceptionTypeEnum;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  employee?: EmployeeWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  slots_every?: ExceptionSlotWhereInput;
  slots_some?: ExceptionSlotWhereInput;
  slots_none?: ExceptionSlotWhereInput;
  rejection?: ExceptionRejectionWhereInput;
  authorization?: ExceptionAuthorizationWhereInput;
  cancellation?: ExceptionCancellationWhereInput;
  elimination?: ExceptionEliminationWhereInput;
  owner?: UserWhereInput;
  credits_every?: ScheduleCreditWhereInput;
  credits_some?: ScheduleCreditWhereInput;
  credits_none?: ScheduleCreditWhereInput;
  debits_every?: ScheduleDebitWhereInput;
  debits_some?: ScheduleDebitWhereInput;
  debits_none?: ScheduleDebitWhereInput;
  AND?: ExceptionWhereInput[] | ExceptionWhereInput;
  OR?: ExceptionWhereInput[] | ExceptionWhereInput;
  NOT?: ExceptionWhereInput[] | ExceptionWhereInput;
}

export interface ScheduleCreditCreateInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface ScheduleOfflineElementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleOfflineCategory;
  category_not?: ScheduleOfflineCategory;
  category_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  category_not_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  AND?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
  OR?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
  NOT?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
}

export interface EmployeeCreateOneWithoutCreditsInput {
  create?: EmployeeCreateWithoutCreditsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ShiftSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShiftWhereInput;
  AND?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
  OR?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
  NOT?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
}

export interface EmployeeCreateWithoutCreditsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  events?: EventCreateManyWithoutEmployeeInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ScheduleTimelineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleTimelineElementWhereInput;
  AND?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
  OR?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
}

export interface DepartmentCreateOneWithoutSubordinatesInput {
  create?: DepartmentCreateWithoutSubordinatesInput;
  connect?: DepartmentWhereUniqueInput;
}

export interface ScheduleRestlineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleRestlineElementWhereInput;
  AND?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
  OR?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
}

export interface DepartmentCreateWithoutSubordinatesInput {
  name: String;
  supervisors?: UserCreateManyWithoutDepartmentsInput;
}

export interface ScheduleDebitSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleDebitWhereInput;
  AND?:
    | ScheduleDebitSubscriptionWhereInput[]
    | ScheduleDebitSubscriptionWhereInput;
  OR?:
    | ScheduleDebitSubscriptionWhereInput[]
    | ScheduleDebitSubscriptionWhereInput;
  NOT?:
    | ScheduleDebitSubscriptionWhereInput[]
    | ScheduleDebitSubscriptionWhereInput;
}

export interface UserCreateManyWithoutDepartmentsInput {
  create?:
    | UserCreateWithoutDepartmentsInput[]
    | UserCreateWithoutDepartmentsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ShiftSlotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  index?: Int;
  index_not?: Int;
  index_in?: Int[] | Int;
  index_not_in?: Int[] | Int;
  index_lt?: Int;
  index_lte?: Int;
  index_gt?: Int;
  index_gte?: Int;
  schedule?: ScheduleWhereInput;
  AND?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
  OR?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
  NOT?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
}

export interface UserCreateWithoutDepartmentsInput {
  username: String;
  password: String;
  roles?: UserRoleCreateManyInput;
}

export interface ShiftWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  employee?: EmployeeWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  slots_every?: ShiftSlotWhereInput;
  slots_some?: ShiftSlotWhereInput;
  slots_none?: ShiftSlotWhereInput;
  owner?: UserWhereInput;
  AND?: ShiftWhereInput[] | ShiftWhereInput;
  OR?: ShiftWhereInput[] | ShiftWhereInput;
  NOT?: ShiftWhereInput[] | ShiftWhereInput;
}

export interface ScheduleDebitCreateManyWithoutEmployeeInput {
  create?:
    | ScheduleDebitCreateWithoutEmployeeInput[]
    | ScheduleDebitCreateWithoutEmployeeInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
}

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  employee?: EmployeeWhereInput;
  time?: DateTimeInput;
  time_not?: DateTimeInput;
  time_in?: DateTimeInput[] | DateTimeInput;
  time_not_in?: DateTimeInput[] | DateTimeInput;
  time_lt?: DateTimeInput;
  time_lte?: DateTimeInput;
  time_gt?: DateTimeInput;
  time_gte?: DateTimeInput;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface ScheduleDebitCreateWithoutEmployeeInput {
  category: ScheduleOfflineCategory;
  exception: ExceptionCreateOneWithoutDebitsInput;
  credit: ScheduleCreditCreateOneWithoutDebitInput;
  date: DateTimeInput;
}

export interface HolidaySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HolidayWhereInput;
  AND?: HolidaySubscriptionWhereInput[] | HolidaySubscriptionWhereInput;
  OR?: HolidaySubscriptionWhereInput[] | HolidaySubscriptionWhereInput;
  NOT?: HolidaySubscriptionWhereInput[] | HolidaySubscriptionWhereInput;
}

export interface ExceptionCreateOneWithoutDebitsInput {
  create?: ExceptionCreateWithoutDebitsInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface UserRoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: UserRoleWhereInput[] | UserRoleWhereInput;
  OR?: UserRoleWhereInput[] | UserRoleWhereInput;
  NOT?: UserRoleWhereInput[] | UserRoleWhereInput;
}

export interface ExceptionCreateWithoutDebitsInput {
  type: ExceptionTypeEnum;
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  rejection?: ExceptionRejectionCreateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationCreateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
}

export interface ExceptionRejectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionRejectionWhereInput;
  AND?:
    | ExceptionRejectionSubscriptionWhereInput[]
    | ExceptionRejectionSubscriptionWhereInput;
  OR?:
    | ExceptionRejectionSubscriptionWhereInput[]
    | ExceptionRejectionSubscriptionWhereInput;
  NOT?:
    | ExceptionRejectionSubscriptionWhereInput[]
    | ExceptionRejectionSubscriptionWhereInput;
}

export interface EmployeeCreateOneWithoutExceptionsInput {
  create?: EmployeeCreateWithoutExceptionsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ExceptionCancellationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionCancellationWhereInput;
  AND?:
    | ExceptionCancellationSubscriptionWhereInput[]
    | ExceptionCancellationSubscriptionWhereInput;
  OR?:
    | ExceptionCancellationSubscriptionWhereInput[]
    | ExceptionCancellationSubscriptionWhereInput;
  NOT?:
    | ExceptionCancellationSubscriptionWhereInput[]
    | ExceptionCancellationSubscriptionWhereInput;
}

export interface EmployeeCreateWithoutExceptionsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  events?: EventCreateManyWithoutEmployeeInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ExceptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionWhereInput;
  AND?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
  OR?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
  NOT?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
}

export interface ScheduleCreditCreateManyWithoutEmployeeInput {
  create?:
    | ScheduleCreditCreateWithoutEmployeeInput[]
    | ScheduleCreditCreateWithoutEmployeeInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
}

export interface DepartmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  subordinates_every?: EmployeeWhereInput;
  subordinates_some?: EmployeeWhereInput;
  subordinates_none?: EmployeeWhereInput;
  supervisors_every?: UserWhereInput;
  supervisors_some?: UserWhereInput;
  supervisors_none?: UserWhereInput;
  AND?: DepartmentWhereInput[] | DepartmentWhereInput;
  OR?: DepartmentWhereInput[] | DepartmentWhereInput;
  NOT?: DepartmentWhereInput[] | DepartmentWhereInput;
}

export interface ScheduleCreditCreateWithoutEmployeeInput {
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface ExceptionCreateOneWithoutCreditsInput {
  create?: ExceptionCreateWithoutCreditsInput;
  connect?: ExceptionWhereUniqueInput;
}

export type DirectCreditWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionCreateWithoutCreditsInput {
  type: ExceptionTypeEnum;
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  rejection?: ExceptionRejectionCreateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationCreateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface DirectCreditSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DirectCreditWhereInput;
  AND?:
    | DirectCreditSubscriptionWhereInput[]
    | DirectCreditSubscriptionWhereInput;
  OR?:
    | DirectCreditSubscriptionWhereInput[]
    | DirectCreditSubscriptionWhereInput;
  NOT?:
    | DirectCreditSubscriptionWhereInput[]
    | DirectCreditSubscriptionWhereInput;
}

export interface ExceptionRejectionCreateOneWithoutExceptionInput {
  create?: ExceptionRejectionCreateWithoutExceptionInput;
  connect?: ExceptionRejectionWhereUniqueInput;
}

export interface AttendanceCycleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttendanceCycleWhereInput;
  AND?:
    | AttendanceCycleSubscriptionWhereInput[]
    | AttendanceCycleSubscriptionWhereInput;
  OR?:
    | AttendanceCycleSubscriptionWhereInput[]
    | AttendanceCycleSubscriptionWhereInput;
  NOT?:
    | AttendanceCycleSubscriptionWhereInput[]
    | AttendanceCycleSubscriptionWhereInput;
}

export interface ExceptionRejectionCreateWithoutExceptionInput {
  owner: UserCreateOneInput;
  description?: String;
}

export interface UserRoleUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface ExceptionAuthorizationCreateOneWithoutExceptionInput {
  create?: ExceptionAuthorizationCreateWithoutExceptionInput;
  connect?: ExceptionAuthorizationWhereUniqueInput;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  password?: String;
}

export interface ExceptionAuthorizationCreateWithoutExceptionInput {
  owner: UserCreateOneInput;
  description?: String;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  departments?: DepartmentUpdateManyWithoutSupervisorsInput;
  roles?: UserRoleUpdateManyInput;
}

export interface ExceptionCancellationCreateOneWithoutExceptionInput {
  create?: ExceptionCancellationCreateWithoutExceptionInput;
  connect?: ExceptionCancellationWhereUniqueInput;
}

export interface ShiftSlotUpdateInput {
  index?: Int;
  schedule?: ScheduleUpdateOneRequiredInput;
}

export interface ExceptionCancellationCreateWithoutExceptionInput {
  owner: UserCreateOneInput;
  description?: String;
}

export interface ShiftUpdateManyMutationInput {
  description?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface ExceptionEliminationCreateOneWithoutExceptionInput {
  create?: ExceptionEliminationCreateWithoutExceptionInput;
  connect?: ExceptionEliminationWhereUniqueInput;
}

export interface EmployeeUpsertWithoutShiftsInput {
  update: EmployeeUpdateWithoutShiftsDataInput;
  create: EmployeeCreateWithoutShiftsInput;
}

export interface ExceptionEliminationCreateWithoutExceptionInput {
  owner: UserCreateOneInput;
  description?: String;
}

export interface EmployeeUpdateOneRequiredWithoutShiftsInput {
  create?: EmployeeCreateWithoutShiftsInput;
  update?: EmployeeUpdateWithoutShiftsDataInput;
  upsert?: EmployeeUpsertWithoutShiftsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleDebitCreateManyWithoutExceptionInput {
  create?:
    | ScheduleDebitCreateWithoutExceptionInput[]
    | ScheduleDebitCreateWithoutExceptionInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
}

export type ExceptionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitCreateWithoutExceptionInput {
  employee: EmployeeCreateOneWithoutDebitsInput;
  category: ScheduleOfflineCategory;
  credit: ScheduleCreditCreateOneWithoutDebitInput;
  date: DateTimeInput;
}

export interface EmployeeCreateOneWithoutShiftsInput {
  create?: EmployeeCreateWithoutShiftsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeCreateOneWithoutDebitsInput {
  create?: EmployeeCreateWithoutDebitsInput;
  connect?: EmployeeWhereUniqueInput;
}

export type ExceptionAuthorizationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EmployeeCreateWithoutDebitsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  events?: EventCreateManyWithoutEmployeeInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
}

export interface ScheduleTimelineElementUpdateManyMutationInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ScheduleCreditCreateOneWithoutDebitInput {
  create?: ScheduleCreditCreateWithoutDebitInput;
  connect?: ScheduleCreditWhereUniqueInput;
}

export interface ScheduleRestlineElementUpdateManyMutationInput {
  category?: ScheduleRestlineCategory;
  duration?: Int;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ScheduleCreditCreateWithoutDebitInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
}

export interface ScheduleRestlineElementUpdateInput {
  category?: ScheduleRestlineCategory;
  duration?: Int;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface DirectCreditCreateOneWithoutCreditsInput {
  create?: DirectCreditCreateWithoutCreditsInput;
  connect?: DirectCreditWhereUniqueInput;
}

export interface ScheduleOfflineElementUpdateInput {
  category?: ScheduleOfflineCategory;
}

export interface DirectCreditCreateWithoutCreditsInput {
  owner: UserCreateOneInput;
  employee: EmployeeCreateOneInput;
  description?: String;
}

export type ExceptionEliminationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EmployeeCreateOneInput {
  create?: EmployeeCreateInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleDebitCreateInput {
  employee: EmployeeCreateOneWithoutDebitsInput;
  category: ScheduleOfflineCategory;
  exception: ExceptionCreateOneWithoutDebitsInput;
  credit: ScheduleCreditCreateOneWithoutDebitInput;
  date: DateTimeInput;
}

export interface EmployeeCreateInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  events?: EventCreateManyWithoutEmployeeInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ScheduleCreditUpdateInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface HolidayCreateOneInput {
  create?: HolidayCreateInput;
  connect?: HolidayWhereUniqueInput;
}

export interface ScheduleCategoryConfigUpdateManyMutationInput {
  category?: ScheduleCategory;
  backgroundColor?: String;
  foregroundColor?: String;
  description?: String;
}

export interface HolidayCreateInput {
  date: DateTimeInput;
  name: String;
}

export interface ScheduleCategoryConfigCreateInput {
  category?: ScheduleCategory;
  backgroundColor?: String;
  foregroundColor?: String;
  description?: String;
}

export interface ScheduleDebitCreateOneWithoutCreditInput {
  create?: ScheduleDebitCreateWithoutCreditInput;
  connect?: ScheduleDebitWhereUniqueInput;
}

export type ExceptionSlotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitCreateWithoutCreditInput {
  employee: EmployeeCreateOneWithoutDebitsInput;
  category: ScheduleOfflineCategory;
  exception: ExceptionCreateOneWithoutDebitsInput;
  date: DateTimeInput;
}

export interface HolidayUpdateManyMutationInput {
  date?: DateTimeInput;
  name?: String;
}

export interface ScheduleCreditCreateManyWithoutSourceExceptionInput {
  create?:
    | ScheduleCreditCreateWithoutSourceExceptionInput[]
    | ScheduleCreditCreateWithoutSourceExceptionInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
}

export type FieldOptionLabelWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleCreditCreateWithoutSourceExceptionInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface FieldOptionLabelWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  field?: String;
  field_not?: String;
  field_in?: String[] | String;
  field_not_in?: String[] | String;
  field_lt?: String;
  field_lte?: String;
  field_gt?: String;
  field_gte?: String;
  field_contains?: String;
  field_not_contains?: String;
  field_starts_with?: String;
  field_not_starts_with?: String;
  field_ends_with?: String;
  field_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  AND?: FieldOptionLabelWhereInput[] | FieldOptionLabelWhereInput;
  OR?: FieldOptionLabelWhereInput[] | FieldOptionLabelWhereInput;
  NOT?: FieldOptionLabelWhereInput[] | FieldOptionLabelWhereInput;
}

export interface DepartmentUpdateInput {
  name?: String;
  subordinates?: EmployeeUpdateManyWithoutDepartmentInput;
  supervisors?: UserUpdateManyWithoutDepartmentsInput;
}

export interface FieldOptionLabelCreateInput {
  field: String;
  value: String;
  label?: String;
}

export interface EmployeeUpdateManyWithoutDepartmentInput {
  create?:
    | EmployeeCreateWithoutDepartmentInput[]
    | EmployeeCreateWithoutDepartmentInput;
  delete?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  disconnect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  update?:
    | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput;
  upsert?:
    | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput;
}

export interface ExceptionSlotUpdateInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  date?: DateTimeInput;
  source1?: ScheduleCreditUpdateOneInput;
  source2?: ScheduleCreditUpdateOneInput;
}

export interface EmployeeUpdateWithWhereUniqueWithoutDepartmentInput {
  where: EmployeeWhereUniqueInput;
  data: EmployeeUpdateWithoutDepartmentDataInput;
}

export interface ExceptionRejectionUpdateManyMutationInput {
  description?: String;
}

export interface EmployeeUpdateWithoutDepartmentDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  events?: EventUpdateManyWithoutEmployeeInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface ExceptionUpdateWithoutRejectionDataInput {
  type?: ExceptionTypeEnum;
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationUpdateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface EventUpdateManyWithoutEmployeeInput {
  create?: EventCreateWithoutEmployeeInput[] | EventCreateWithoutEmployeeInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutEmployeeInput[]
    | EventUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutEmployeeInput[]
    | EventUpsertWithWhereUniqueWithoutEmployeeInput;
}

export type ScheduleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
}>;

export interface EventUpdateWithWhereUniqueWithoutEmployeeInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutEmployeeDataInput;
}

export interface ExceptionCreateWithoutRejectionInput {
  type: ExceptionTypeEnum;
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationCreateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface EventUpdateWithoutEmployeeDataInput {
  time?: DateTimeInput;
}

export interface ExceptionRejectionCreateInput {
  exception: ExceptionCreateOneWithoutRejectionInput;
  owner: UserCreateOneInput;
  description?: String;
}

export interface EventUpsertWithWhereUniqueWithoutEmployeeInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutEmployeeDataInput;
  create: EventCreateWithoutEmployeeInput;
}

export interface ExceptionEliminationUpdateManyMutationInput {
  description?: String;
}

export interface ShiftUpdateManyWithoutEmployeeInput {
  create?: ShiftCreateWithoutEmployeeInput[] | ShiftCreateWithoutEmployeeInput;
  delete?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  connect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  disconnect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  update?:
    | ShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ShiftUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ShiftUpsertWithWhereUniqueWithoutEmployeeInput;
}

export interface ScheduleCategoryConfigWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleCategory;
  category_not?: ScheduleCategory;
  category_in?: ScheduleCategory[] | ScheduleCategory;
  category_not_in?: ScheduleCategory[] | ScheduleCategory;
  backgroundColor?: String;
  backgroundColor_not?: String;
  backgroundColor_in?: String[] | String;
  backgroundColor_not_in?: String[] | String;
  backgroundColor_lt?: String;
  backgroundColor_lte?: String;
  backgroundColor_gt?: String;
  backgroundColor_gte?: String;
  backgroundColor_contains?: String;
  backgroundColor_not_contains?: String;
  backgroundColor_starts_with?: String;
  backgroundColor_not_starts_with?: String;
  backgroundColor_ends_with?: String;
  backgroundColor_not_ends_with?: String;
  foregroundColor?: String;
  foregroundColor_not?: String;
  foregroundColor_in?: String[] | String;
  foregroundColor_not_in?: String[] | String;
  foregroundColor_lt?: String;
  foregroundColor_lte?: String;
  foregroundColor_gt?: String;
  foregroundColor_gte?: String;
  foregroundColor_contains?: String;
  foregroundColor_not_contains?: String;
  foregroundColor_starts_with?: String;
  foregroundColor_not_starts_with?: String;
  foregroundColor_ends_with?: String;
  foregroundColor_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ScheduleCategoryConfigWhereInput[] | ScheduleCategoryConfigWhereInput;
  OR?: ScheduleCategoryConfigWhereInput[] | ScheduleCategoryConfigWhereInput;
  NOT?: ScheduleCategoryConfigWhereInput[] | ScheduleCategoryConfigWhereInput;
}

export interface ShiftUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ShiftWhereUniqueInput;
  data: ShiftUpdateWithoutEmployeeDataInput;
}

export interface ExceptionUpdateWithoutEliminationDataInput {
  type?: ExceptionTypeEnum;
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  rejection?: ExceptionRejectionUpdateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ShiftUpdateWithoutEmployeeDataInput {
  description?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface ExceptionEliminationUpdateInput {
  exception?: ExceptionUpdateOneRequiredWithoutEliminationInput;
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface EmployeeCreateWithoutEventsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ExceptionCreateWithoutEliminationInput {
  type: ExceptionTypeEnum;
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  rejection?: ExceptionRejectionCreateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface ShiftSlotUpdateWithWhereUniqueNestedInput {
  where: ShiftSlotWhereUniqueInput;
  data: ShiftSlotUpdateDataInput;
}

export interface ExceptionEliminationCreateInput {
  exception: ExceptionCreateOneWithoutEliminationInput;
  owner: UserCreateOneInput;
  description?: String;
}

export interface ShiftSlotUpdateDataInput {
  index?: Int;
  schedule?: ScheduleUpdateOneRequiredInput;
}

export interface ExceptionCancellationUpdateManyMutationInput {
  description?: String;
}

export interface ScheduleUpdateOneRequiredInput {
  create?: ScheduleCreateInput;
  update?: ScheduleUpdateDataInput;
  upsert?: ScheduleUpsertNestedInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ExceptionUpdateWithoutCancellationDataInput {
  type?: ExceptionTypeEnum;
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  rejection?: ExceptionRejectionUpdateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ScheduleUpdateDataInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime?: Int;
  innerBound?: Int;
  outerBound?: Int;
  timeline?: ScheduleTimelineElementUpdateManyInput;
  restline?: ScheduleRestlineElementUpdateManyInput;
  offline1?: ScheduleOfflineElementUpdateOneInput;
  offline2?: ScheduleOfflineElementUpdateOneInput;
}

export interface ExceptionUpdateOneRequiredWithoutCancellationInput {
  create?: ExceptionCreateWithoutCancellationInput;
  update?: ExceptionUpdateWithoutCancellationDataInput;
  upsert?: ExceptionUpsertWithoutCancellationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ScheduleTimelineElementUpdateManyInput {
  create?:
    | ScheduleTimelineElementCreateInput[]
    | ScheduleTimelineElementCreateInput;
  update?:
    | ScheduleTimelineElementUpdateWithWhereUniqueNestedInput[]
    | ScheduleTimelineElementUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ScheduleTimelineElementUpsertWithWhereUniqueNestedInput[]
    | ScheduleTimelineElementUpsertWithWhereUniqueNestedInput;
  delete?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
  connect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
  disconnect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
}

export interface ExceptionCreateWithoutCancellationInput {
  type: ExceptionTypeEnum;
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  rejection?: ExceptionRejectionCreateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface ScheduleTimelineElementUpdateWithWhereUniqueNestedInput {
  where: ScheduleTimelineElementWhereUniqueInput;
  data: ScheduleTimelineElementUpdateDataInput;
}

export type ScheduleRestlineElementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleTimelineElementUpdateDataInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ExceptionAuthorizationUpdateManyMutationInput {
  description?: String;
}

export interface ScheduleTimelineElementUpsertWithWhereUniqueNestedInput {
  where: ScheduleTimelineElementWhereUniqueInput;
  update: ScheduleTimelineElementUpdateDataInput;
  create: ScheduleTimelineElementCreateInput;
}

export type ScheduleTimelineElementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleRestlineElementUpdateManyInput {
  create?:
    | ScheduleRestlineElementCreateInput[]
    | ScheduleRestlineElementCreateInput;
  update?:
    | ScheduleRestlineElementUpdateWithWhereUniqueNestedInput[]
    | ScheduleRestlineElementUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ScheduleRestlineElementUpsertWithWhereUniqueNestedInput[]
    | ScheduleRestlineElementUpsertWithWhereUniqueNestedInput;
  delete?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
  connect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
  disconnect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
}

export interface ExceptionUpdateOneRequiredWithoutAuthorizationInput {
  create?: ExceptionCreateWithoutAuthorizationInput;
  update?: ExceptionUpdateWithoutAuthorizationDataInput;
  upsert?: ExceptionUpsertWithoutAuthorizationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ScheduleRestlineElementUpdateWithWhereUniqueNestedInput {
  where: ScheduleRestlineElementWhereUniqueInput;
  data: ScheduleRestlineElementUpdateDataInput;
}

export type ShiftWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleRestlineElementUpdateDataInput {
  category?: ScheduleRestlineCategory;
  duration?: Int;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ExceptionCreateOneWithoutAuthorizationInput {
  create?: ExceptionCreateWithoutAuthorizationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ScheduleRestlineElementUpsertWithWhereUniqueNestedInput {
  where: ScheduleRestlineElementWhereUniqueInput;
  update: ScheduleRestlineElementUpdateDataInput;
  create: ScheduleRestlineElementCreateInput;
}

export type ShiftSlotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleOfflineElementUpdateOneInput {
  create?: ScheduleOfflineElementCreateInput;
  update?: ScheduleOfflineElementUpdateDataInput;
  upsert?: ScheduleOfflineElementUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScheduleOfflineElementWhereUniqueInput;
}

export interface ExceptionUpdateInput {
  type?: ExceptionTypeEnum;
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  rejection?: ExceptionRejectionUpdateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationUpdateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ScheduleOfflineElementUpdateDataInput {
  category?: ScheduleOfflineCategory;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface ScheduleOfflineElementUpsertNestedInput {
  update: ScheduleOfflineElementUpdateDataInput;
  create: ScheduleOfflineElementCreateInput;
}

export interface EventSyncLogUpdateInput {
  from?: DateTimeInput;
  to?: DateTimeInput;
}

export interface ScheduleUpsertNestedInput {
  update: ScheduleUpdateDataInput;
  create: ScheduleCreateInput;
}

export type UserRoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface ShiftSlotUpsertWithWhereUniqueNestedInput {
  where: ShiftSlotWhereUniqueInput;
  update: ShiftSlotUpdateDataInput;
  create: ShiftSlotCreateInput;
}

export interface EmployeeUpsertWithoutEventsInput {
  update: EmployeeUpdateWithoutEventsDataInput;
  create: EmployeeCreateWithoutEventsInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface AttendanceCycleUpdateInput {
  name?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface HolidayWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: HolidayWhereInput[] | HolidayWhereInput;
  OR?: HolidayWhereInput[] | HolidayWhereInput;
  NOT?: HolidayWhereInput[] | HolidayWhereInput;
}

export interface EmployeeUpdateOneRequiredWithoutEventsInput {
  create?: EmployeeCreateWithoutEventsInput;
  update?: EmployeeUpdateWithoutEventsDataInput;
  upsert?: EmployeeUpsertWithoutEventsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ExceptionRejectionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  exception?: ExceptionWhereInput;
  owner?: UserWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ExceptionRejectionWhereInput[] | ExceptionRejectionWhereInput;
  OR?: ExceptionRejectionWhereInput[] | ExceptionRejectionWhereInput;
  NOT?: ExceptionRejectionWhereInput[] | ExceptionRejectionWhereInput;
}

export interface DepartmentCreateInput {
  name: String;
  subordinates?: EmployeeCreateManyWithoutDepartmentInput;
  supervisors?: UserCreateManyWithoutDepartmentsInput;
}

export interface ExceptionCancellationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  exception?: ExceptionWhereInput;
  owner?: UserWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ExceptionCancellationWhereInput[] | ExceptionCancellationWhereInput;
  OR?: ExceptionCancellationWhereInput[] | ExceptionCancellationWhereInput;
  NOT?: ExceptionCancellationWhereInput[] | ExceptionCancellationWhereInput;
}

export interface EmployeeCreateWithoutDepartmentInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  events?: EventCreateManyWithoutEmployeeInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ScheduleCreditWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  employee?: EmployeeWhereInput;
  category?: ScheduleOfflineCategory;
  category_not?: ScheduleOfflineCategory;
  category_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  category_not_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceType_not?: ScheduleCreditSourceEnum;
  sourceType_in?: ScheduleCreditSourceEnum[] | ScheduleCreditSourceEnum;
  sourceType_not_in?: ScheduleCreditSourceEnum[] | ScheduleCreditSourceEnum;
  sourceException?: ExceptionWhereInput;
  sourceDirect?: DirectCreditWhereInput;
  sourceConcurentHoliday?: HolidayWhereInput;
  sourceDate?: DateTimeInput;
  sourceDate_not?: DateTimeInput;
  sourceDate_in?: DateTimeInput[] | DateTimeInput;
  sourceDate_not_in?: DateTimeInput[] | DateTimeInput;
  sourceDate_lt?: DateTimeInput;
  sourceDate_lte?: DateTimeInput;
  sourceDate_gt?: DateTimeInput;
  sourceDate_gte?: DateTimeInput;
  debit?: ScheduleDebitWhereInput;
  AND?: ScheduleCreditWhereInput[] | ScheduleCreditWhereInput;
  OR?: ScheduleCreditWhereInput[] | ScheduleCreditWhereInput;
  NOT?: ScheduleCreditWhereInput[] | ScheduleCreditWhereInput;
}

export interface EventCreateWithoutEmployeeInput {
  time: DateTimeInput;
}

export interface ExceptionSlotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  schedule?: ScheduleWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  source1?: ScheduleCreditWhereInput;
  source2?: ScheduleCreditWhereInput;
  AND?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
  OR?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
  NOT?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
}

export interface ShiftCreateWithoutEmployeeInput {
  description?: String;
  startDate: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotCreateManyInput;
  owner: UserCreateOneInput;
}

export interface UserRoleUpdateManyInput {
  create?: UserRoleCreateInput[] | UserRoleCreateInput;
  update?:
    | UserRoleUpdateWithWhereUniqueNestedInput[]
    | UserRoleUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserRoleUpsertWithWhereUniqueNestedInput[]
    | UserRoleUpsertWithWhereUniqueNestedInput;
  delete?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
  connect?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
  disconnect?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
}

export interface ShiftSlotCreateInput {
  index: Int;
  schedule: ScheduleCreateOneInput;
}

export interface UserRoleUpdateWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput;
  data: UserRoleUpdateDataInput;
}

export interface ScheduleCreateInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime: Int;
  innerBound?: Int;
  outerBound?: Int;
  timeline?: ScheduleTimelineElementCreateManyInput;
  restline?: ScheduleRestlineElementCreateManyInput;
  offline1?: ScheduleOfflineElementCreateOneInput;
  offline2?: ScheduleOfflineElementCreateOneInput;
}

export interface UserRoleUpdateDataInput {
  name?: String;
  description?: String;
}

export interface ScheduleTimelineElementCreateInput {
  category: ScheduleTimelineCategory;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface UserRoleUpsertWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput;
  update: UserRoleUpdateDataInput;
  create: UserRoleCreateInput;
}

export interface ScheduleRestlineElementCreateInput {
  category: ScheduleRestlineCategory;
  duration: Int;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ScheduleOfflineElementCreateInput {
  category: ScheduleOfflineCategory;
}

export interface ShiftUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ShiftWhereUniqueInput;
  update: ShiftUpdateWithoutEmployeeDataInput;
  create: ShiftCreateWithoutEmployeeInput;
}

export interface UserCreateInput {
  username: String;
  password: String;
  departments?: DepartmentCreateManyWithoutSupervisorsInput;
  roles?: UserRoleCreateManyInput;
}

export interface ExceptionUpdateManyWithoutEmployeeInput {
  create?:
    | ExceptionCreateWithoutEmployeeInput[]
    | ExceptionCreateWithoutEmployeeInput;
  delete?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
  connect?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
  disconnect?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
  update?:
    | ExceptionUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ExceptionUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ExceptionUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ExceptionUpsertWithWhereUniqueWithoutEmployeeInput;
}

export interface DepartmentCreateWithoutSupervisorsInput {
  name: String;
  subordinates?: EmployeeCreateManyWithoutDepartmentInput;
}

export interface ExceptionUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ExceptionWhereUniqueInput;
  data: ExceptionUpdateWithoutEmployeeDataInput;
}

export interface UserRoleCreateInput {
  name: String;
  description?: String;
}

export interface ExceptionUpdateWithoutEmployeeDataInput {
  type?: ExceptionTypeEnum;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  rejection?: ExceptionRejectionUpdateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationUpdateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ExceptionCreateWithoutEmployeeInput {
  type: ExceptionTypeEnum;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  rejection?: ExceptionRejectionCreateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationCreateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface ExceptionSlotUpdateManyInput {
  create?: ExceptionSlotCreateInput[] | ExceptionSlotCreateInput;
  update?:
    | ExceptionSlotUpdateWithWhereUniqueNestedInput[]
    | ExceptionSlotUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ExceptionSlotUpsertWithWhereUniqueNestedInput[]
    | ExceptionSlotUpsertWithWhereUniqueNestedInput;
  delete?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
  connect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
  disconnect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ExceptionSlotUpdateWithWhereUniqueNestedInput {
  where: ExceptionSlotWhereUniqueInput;
  data: ExceptionSlotUpdateDataInput;
}

export interface ScheduleRestlineElementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleRestlineCategory;
  category_not?: ScheduleRestlineCategory;
  category_in?: ScheduleRestlineCategory[] | ScheduleRestlineCategory;
  category_not_in?: ScheduleRestlineCategory[] | ScheduleRestlineCategory;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  startTime?: Int;
  startTime_not?: Int;
  startTime_in?: Int[] | Int;
  startTime_not_in?: Int[] | Int;
  startTime_lt?: Int;
  startTime_lte?: Int;
  startTime_gt?: Int;
  startTime_gte?: Int;
  endTime?: Int;
  endTime_not?: Int;
  endTime_in?: Int[] | Int;
  endTime_not_in?: Int[] | Int;
  endTime_lt?: Int;
  endTime_lte?: Int;
  endTime_gt?: Int;
  endTime_gte?: Int;
  startEventRequired?: Boolean;
  startEventRequired_not?: Boolean;
  endEventRequired?: Boolean;
  endEventRequired_not?: Boolean;
  AND?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
  OR?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
  NOT?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
}

export interface ExceptionSlotUpdateDataInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  date?: DateTimeInput;
  source1?: ScheduleCreditUpdateOneInput;
  source2?: ScheduleCreditUpdateOneInput;
}

export interface ScheduleOfflineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleOfflineElementWhereInput;
  AND?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
  OR?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
}

export interface ScheduleCreditUpdateOneInput {
  create?: ScheduleCreditCreateInput;
  update?: ScheduleCreditUpdateDataInput;
  upsert?: ScheduleCreditUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScheduleCreditWhereUniqueInput;
}

export interface ScheduleCreditSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleCreditWhereInput;
  AND?:
    | ScheduleCreditSubscriptionWhereInput[]
    | ScheduleCreditSubscriptionWhereInput;
  OR?:
    | ScheduleCreditSubscriptionWhereInput[]
    | ScheduleCreditSubscriptionWhereInput;
  NOT?:
    | ScheduleCreditSubscriptionWhereInput[]
    | ScheduleCreditSubscriptionWhereInput;
}

export interface ScheduleCreditUpdateDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface ScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleWhereInput;
  AND?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  OR?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  NOT?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
}

export interface EmployeeUpdateOneRequiredWithoutCreditsInput {
  create?: EmployeeCreateWithoutCreditsInput;
  update?: EmployeeUpdateWithoutCreditsDataInput;
  upsert?: EmployeeUpsertWithoutCreditsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ExceptionSlotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionSlotWhereInput;
  AND?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
  OR?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
  NOT?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
}

export interface EmployeeUpdateWithoutCreditsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  events?: EventUpdateManyWithoutEmployeeInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface ExceptionAuthorizationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionAuthorizationWhereInput;
  AND?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
  OR?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
  NOT?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
}

export interface DepartmentUpdateOneWithoutSubordinatesInput {
  create?: DepartmentCreateWithoutSubordinatesInput;
  update?: DepartmentUpdateWithoutSubordinatesDataInput;
  upsert?: DepartmentUpsertWithoutSubordinatesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DepartmentWhereUniqueInput;
}

export interface EventSyncLogSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventSyncLogWhereInput;
  AND?:
    | EventSyncLogSubscriptionWhereInput[]
    | EventSyncLogSubscriptionWhereInput;
  OR?:
    | EventSyncLogSubscriptionWhereInput[]
    | EventSyncLogSubscriptionWhereInput;
  NOT?:
    | EventSyncLogSubscriptionWhereInput[]
    | EventSyncLogSubscriptionWhereInput;
}

export interface DepartmentUpdateWithoutSubordinatesDataInput {
  name?: String;
  supervisors?: UserUpdateManyWithoutDepartmentsInput;
}

export interface EmployeeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  nameFirst?: String;
  nameFirst_not?: String;
  nameFirst_in?: String[] | String;
  nameFirst_not_in?: String[] | String;
  nameFirst_lt?: String;
  nameFirst_lte?: String;
  nameFirst_gt?: String;
  nameFirst_gte?: String;
  nameFirst_contains?: String;
  nameFirst_not_contains?: String;
  nameFirst_starts_with?: String;
  nameFirst_not_starts_with?: String;
  nameFirst_ends_with?: String;
  nameFirst_not_ends_with?: String;
  nameMiddle?: String;
  nameMiddle_not?: String;
  nameMiddle_in?: String[] | String;
  nameMiddle_not_in?: String[] | String;
  nameMiddle_lt?: String;
  nameMiddle_lte?: String;
  nameMiddle_gt?: String;
  nameMiddle_gte?: String;
  nameMiddle_contains?: String;
  nameMiddle_not_contains?: String;
  nameMiddle_starts_with?: String;
  nameMiddle_not_starts_with?: String;
  nameMiddle_ends_with?: String;
  nameMiddle_not_ends_with?: String;
  namePaternal?: String;
  namePaternal_not?: String;
  namePaternal_in?: String[] | String;
  namePaternal_not_in?: String[] | String;
  namePaternal_lt?: String;
  namePaternal_lte?: String;
  namePaternal_gt?: String;
  namePaternal_gte?: String;
  namePaternal_contains?: String;
  namePaternal_not_contains?: String;
  namePaternal_starts_with?: String;
  namePaternal_not_starts_with?: String;
  namePaternal_ends_with?: String;
  namePaternal_not_ends_with?: String;
  nameMaternal?: String;
  nameMaternal_not?: String;
  nameMaternal_in?: String[] | String;
  nameMaternal_not_in?: String[] | String;
  nameMaternal_lt?: String;
  nameMaternal_lte?: String;
  nameMaternal_gt?: String;
  nameMaternal_gte?: String;
  nameMaternal_contains?: String;
  nameMaternal_not_contains?: String;
  nameMaternal_starts_with?: String;
  nameMaternal_not_starts_with?: String;
  nameMaternal_ends_with?: String;
  nameMaternal_not_ends_with?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentType_not?: EmployeeDocumentTypeEnum;
  documentType_in?: EmployeeDocumentTypeEnum[] | EmployeeDocumentTypeEnum;
  documentType_not_in?: EmployeeDocumentTypeEnum[] | EmployeeDocumentTypeEnum;
  documentNumber?: String;
  documentNumber_not?: String;
  documentNumber_in?: String[] | String;
  documentNumber_not_in?: String[] | String;
  documentNumber_lt?: String;
  documentNumber_lte?: String;
  documentNumber_gt?: String;
  documentNumber_gte?: String;
  documentNumber_contains?: String;
  documentNumber_not_contains?: String;
  documentNumber_starts_with?: String;
  documentNumber_not_starts_with?: String;
  documentNumber_ends_with?: String;
  documentNumber_not_ends_with?: String;
  sex?: EmployeeSexEnum;
  sex_not?: EmployeeSexEnum;
  sex_in?: EmployeeSexEnum[] | EmployeeSexEnum;
  sex_not_in?: EmployeeSexEnum[] | EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  dateOfBirth_not?: DateTimeInput;
  dateOfBirth_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_not_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_lt?: DateTimeInput;
  dateOfBirth_lte?: DateTimeInput;
  dateOfBirth_gt?: DateTimeInput;
  dateOfBirth_gte?: DateTimeInput;
  nationality?: String;
  nationality_not?: String;
  nationality_in?: String[] | String;
  nationality_not_in?: String[] | String;
  nationality_lt?: String;
  nationality_lte?: String;
  nationality_gt?: String;
  nationality_gte?: String;
  nationality_contains?: String;
  nationality_not_contains?: String;
  nationality_starts_with?: String;
  nationality_not_starts_with?: String;
  nationality_ends_with?: String;
  nationality_not_ends_with?: String;
  jubilado?: Boolean;
  jubilado_not?: Boolean;
  personaConDiscapacidad?: Boolean;
  personaConDiscapacidad_not?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad_not?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  cajaDeSalud_not?: EmployeeCajaDeSaludEnum;
  cajaDeSalud_in?: EmployeeCajaDeSaludEnum[] | EmployeeCajaDeSaludEnum;
  cajaDeSalud_not_in?: EmployeeCajaDeSaludEnum[] | EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  aportaAFP_not?: Boolean;
  AFP?: EmployeeAFPEnum;
  AFP_not?: EmployeeAFPEnum;
  AFP_in?: EmployeeAFPEnum[] | EmployeeAFPEnum;
  AFP_not_in?: EmployeeAFPEnum[] | EmployeeAFPEnum;
  cargo?: String;
  cargo_not?: String;
  cargo_in?: String[] | String;
  cargo_not_in?: String[] | String;
  cargo_lt?: String;
  cargo_lte?: String;
  cargo_gt?: String;
  cargo_gte?: String;
  cargo_contains?: String;
  cargo_not_contains?: String;
  cargo_starts_with?: String;
  cargo_not_starts_with?: String;
  cargo_ends_with?: String;
  cargo_not_ends_with?: String;
  zkTimePin?: Int;
  zkTimePin_not?: Int;
  zkTimePin_in?: Int[] | Int;
  zkTimePin_not_in?: Int[] | Int;
  zkTimePin_lt?: Int;
  zkTimePin_lte?: Int;
  zkTimePin_gt?: Int;
  zkTimePin_gte?: Int;
  department?: DepartmentWhereInput;
  events_every?: EventWhereInput;
  events_some?: EventWhereInput;
  events_none?: EventWhereInput;
  shifts_every?: ShiftWhereInput;
  shifts_some?: ShiftWhereInput;
  shifts_none?: ShiftWhereInput;
  exceptions_every?: ExceptionWhereInput;
  exceptions_some?: ExceptionWhereInput;
  exceptions_none?: ExceptionWhereInput;
  credits_every?: ScheduleCreditWhereInput;
  credits_some?: ScheduleCreditWhereInput;
  credits_none?: ScheduleCreditWhereInput;
  debits_every?: ScheduleDebitWhereInput;
  debits_some?: ScheduleDebitWhereInput;
  debits_none?: ScheduleDebitWhereInput;
  AND?: EmployeeWhereInput[] | EmployeeWhereInput;
  OR?: EmployeeWhereInput[] | EmployeeWhereInput;
  NOT?: EmployeeWhereInput[] | EmployeeWhereInput;
}

export interface UserUpdateManyWithoutDepartmentsInput {
  create?:
    | UserCreateWithoutDepartmentsInput[]
    | UserCreateWithoutDepartmentsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutDepartmentsInput[]
    | UserUpdateWithWhereUniqueWithoutDepartmentsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutDepartmentsInput[]
    | UserUpsertWithWhereUniqueWithoutDepartmentsInput;
}

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithWhereUniqueWithoutDepartmentsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutDepartmentsDataInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutDepartmentsDataInput {
  username?: String;
  password?: String;
  roles?: UserRoleUpdateManyInput;
}

export type EventSyncLogWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpsertWithWhereUniqueWithoutDepartmentsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutDepartmentsDataInput;
  create: UserCreateWithoutDepartmentsInput;
}

export interface EmployeeUpdateWithoutShiftsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  events?: EventUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface DepartmentUpsertWithoutSubordinatesInput {
  update: DepartmentUpdateWithoutSubordinatesDataInput;
  create: DepartmentCreateWithoutSubordinatesInput;
}

export interface EmployeeCreateWithoutShiftsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  events?: EventCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ScheduleDebitUpdateManyWithoutEmployeeInput {
  create?:
    | ScheduleDebitCreateWithoutEmployeeInput[]
    | ScheduleDebitCreateWithoutEmployeeInput;
  delete?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  disconnect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  update?:
    | ScheduleDebitUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleDebitUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ScheduleDebitUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleDebitUpsertWithWhereUniqueWithoutEmployeeInput;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleDebitWhereUniqueInput;
  data: ScheduleDebitUpdateWithoutEmployeeDataInput;
}

export type ExceptionCancellationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitUpdateWithoutEmployeeDataInput {
  category?: ScheduleOfflineCategory;
  exception?: ExceptionUpdateOneRequiredWithoutDebitsInput;
  credit?: ScheduleCreditUpdateOneRequiredWithoutDebitInput;
  date?: DateTimeInput;
}

export interface ScheduleDebitUpdateManyMutationInput {
  category?: ScheduleOfflineCategory;
  date?: DateTimeInput;
}

export interface ExceptionUpdateOneRequiredWithoutDebitsInput {
  create?: ExceptionCreateWithoutDebitsInput;
  update?: ExceptionUpdateWithoutDebitsDataInput;
  upsert?: ExceptionUpsertWithoutDebitsInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ScheduleCreditUpdateManyMutationInput {
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceDate?: DateTimeInput;
}

export interface ExceptionUpdateWithoutDebitsDataInput {
  type?: ExceptionTypeEnum;
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  rejection?: ExceptionRejectionUpdateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationUpdateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
}

export interface ScheduleCategoryConfigUpdateInput {
  category?: ScheduleCategory;
  backgroundColor?: String;
  foregroundColor?: String;
  description?: String;
}

export interface EmployeeUpdateOneRequiredWithoutExceptionsInput {
  create?: EmployeeCreateWithoutExceptionsInput;
  update?: EmployeeUpdateWithoutExceptionsDataInput;
  upsert?: EmployeeUpsertWithoutExceptionsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleUpdateInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime?: Int;
  innerBound?: Int;
  outerBound?: Int;
  timeline?: ScheduleTimelineElementUpdateManyInput;
  restline?: ScheduleRestlineElementUpdateManyInput;
  offline1?: ScheduleOfflineElementUpdateOneInput;
  offline2?: ScheduleOfflineElementUpdateOneInput;
}

export interface EmployeeUpdateWithoutExceptionsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  events?: EventUpdateManyWithoutEmployeeInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface FieldOptionLabelUpdateManyMutationInput {
  field?: String;
  value?: String;
  label?: String;
}

export interface ScheduleCreditUpdateManyWithoutEmployeeInput {
  create?:
    | ScheduleCreditCreateWithoutEmployeeInput[]
    | ScheduleCreditCreateWithoutEmployeeInput;
  delete?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  disconnect?:
    | ScheduleCreditWhereUniqueInput[]
    | ScheduleCreditWhereUniqueInput;
  update?:
    | ScheduleCreditUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleCreditUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ScheduleCreditUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleCreditUpsertWithWhereUniqueWithoutEmployeeInput;
}

export interface ExceptionSlotUpdateManyMutationInput {
  date?: DateTimeInput;
}

export interface ScheduleCreditUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleCreditWhereUniqueInput;
  data: ScheduleCreditUpdateWithoutEmployeeDataInput;
}

export interface ExceptionUpsertWithoutRejectionInput {
  update: ExceptionUpdateWithoutRejectionDataInput;
  create: ExceptionCreateWithoutRejectionInput;
}

export interface ScheduleCreditUpdateWithoutEmployeeDataInput {
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface ExceptionRejectionUpdateInput {
  exception?: ExceptionUpdateOneRequiredWithoutRejectionInput;
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface ExceptionUpdateOneWithoutCreditsInput {
  create?: ExceptionCreateWithoutCreditsInput;
  update?: ExceptionUpdateWithoutCreditsDataInput;
  upsert?: ExceptionUpsertWithoutCreditsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExceptionWhereUniqueInput;
}

export type ScheduleCategoryConfigWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionUpdateWithoutCreditsDataInput {
  type?: ExceptionTypeEnum;
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  rejection?: ExceptionRejectionUpdateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationUpdateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ExceptionUpsertWithoutEliminationInput {
  update: ExceptionUpdateWithoutEliminationDataInput;
  create: ExceptionCreateWithoutEliminationInput;
}

export interface ExceptionRejectionUpdateOneWithoutExceptionInput {
  create?: ExceptionRejectionCreateWithoutExceptionInput;
  update?: ExceptionRejectionUpdateWithoutExceptionDataInput;
  upsert?: ExceptionRejectionUpsertWithoutExceptionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExceptionRejectionWhereUniqueInput;
}

export type ScheduleCreditWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionRejectionUpdateWithoutExceptionDataInput {
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export type ScheduleDebitWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionRejectionUpsertWithoutExceptionInput {
  update: ExceptionRejectionUpdateWithoutExceptionDataInput;
  create: ExceptionRejectionCreateWithoutExceptionInput;
}

export type ScheduleOfflineElementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionAuthorizationUpdateOneWithoutExceptionInput {
  create?: ExceptionAuthorizationCreateWithoutExceptionInput;
  update?: ExceptionAuthorizationUpdateWithoutExceptionDataInput;
  upsert?: ExceptionAuthorizationUpsertWithoutExceptionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExceptionAuthorizationWhereUniqueInput;
}

export interface ExceptionCreateOneWithoutCancellationInput {
  create?: ExceptionCreateWithoutCancellationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ExceptionAuthorizationUpdateWithoutExceptionDataInput {
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface ExceptionUpsertWithoutAuthorizationInput {
  update: ExceptionUpdateWithoutAuthorizationDataInput;
  create: ExceptionCreateWithoutAuthorizationInput;
}

export interface ExceptionAuthorizationUpsertWithoutExceptionInput {
  update: ExceptionAuthorizationUpdateWithoutExceptionDataInput;
  create: ExceptionAuthorizationCreateWithoutExceptionInput;
}

export interface ExceptionAuthorizationUpdateInput {
  exception?: ExceptionUpdateOneRequiredWithoutAuthorizationInput;
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface ExceptionCancellationUpdateOneWithoutExceptionInput {
  create?: ExceptionCancellationCreateWithoutExceptionInput;
  update?: ExceptionCancellationUpdateWithoutExceptionDataInput;
  upsert?: ExceptionCancellationUpsertWithoutExceptionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExceptionCancellationWhereUniqueInput;
}

export interface ExceptionAuthorizationCreateInput {
  exception: ExceptionCreateOneWithoutAuthorizationInput;
  owner: UserCreateOneInput;
  description?: String;
}

export interface ExceptionCancellationUpdateWithoutExceptionDataInput {
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface ExceptionCreateInput {
  type: ExceptionTypeEnum;
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  rejection?: ExceptionRejectionCreateOneWithoutExceptionInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationCreateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface ExceptionCancellationUpsertWithoutExceptionInput {
  update: ExceptionCancellationUpdateWithoutExceptionDataInput;
  create: ExceptionCancellationCreateWithoutExceptionInput;
}

export interface EventSyncLogCreateInput {
  from: DateTimeInput;
  to: DateTimeInput;
}

export interface ExceptionEliminationUpdateOneWithoutExceptionInput {
  create?: ExceptionEliminationCreateWithoutExceptionInput;
  update?: ExceptionEliminationUpdateWithoutExceptionDataInput;
  upsert?: ExceptionEliminationUpsertWithoutExceptionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExceptionEliminationWhereUniqueInput;
}

export interface EmployeeUpdateWithoutEventsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface ExceptionEliminationUpdateWithoutExceptionDataInput {
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface AttendanceCycleUpdateManyMutationInput {
  name?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface ExceptionEliminationUpsertWithoutExceptionInput {
  update: ExceptionEliminationUpdateWithoutExceptionDataInput;
  create: ExceptionEliminationCreateWithoutExceptionInput;
}

export interface EmployeeCreateManyWithoutDepartmentInput {
  create?:
    | EmployeeCreateWithoutDepartmentInput[]
    | EmployeeCreateWithoutDepartmentInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
}

export interface ScheduleDebitUpdateManyWithoutExceptionInput {
  create?:
    | ScheduleDebitCreateWithoutExceptionInput[]
    | ScheduleDebitCreateWithoutExceptionInput;
  delete?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  disconnect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  update?:
    | ScheduleDebitUpdateWithWhereUniqueWithoutExceptionInput[]
    | ScheduleDebitUpdateWithWhereUniqueWithoutExceptionInput;
  upsert?:
    | ScheduleDebitUpsertWithWhereUniqueWithoutExceptionInput[]
    | ScheduleDebitUpsertWithWhereUniqueWithoutExceptionInput;
}

export interface ShiftCreateManyWithoutEmployeeInput {
  create?: ShiftCreateWithoutEmployeeInput[] | ShiftCreateWithoutEmployeeInput;
  connect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
}

export interface ScheduleDebitUpdateWithWhereUniqueWithoutExceptionInput {
  where: ScheduleDebitWhereUniqueInput;
  data: ScheduleDebitUpdateWithoutExceptionDataInput;
}

export interface ScheduleCreateOneInput {
  create?: ScheduleCreateInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ScheduleDebitUpdateWithoutExceptionDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutDebitsInput;
  category?: ScheduleOfflineCategory;
  credit?: ScheduleCreditUpdateOneRequiredWithoutDebitInput;
  date?: DateTimeInput;
}

export interface ScheduleRestlineElementCreateManyInput {
  create?:
    | ScheduleRestlineElementCreateInput[]
    | ScheduleRestlineElementCreateInput;
  connect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
}

export interface EmployeeUpdateOneRequiredWithoutDebitsInput {
  create?: EmployeeCreateWithoutDebitsInput;
  update?: EmployeeUpdateWithoutDebitsDataInput;
  upsert?: EmployeeUpsertWithoutDebitsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface EmployeeUpdateWithoutDebitsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  events?: EventUpdateManyWithoutEmployeeInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
}

export interface UserRoleCreateManyInput {
  create?: UserRoleCreateInput[] | UserRoleCreateInput;
  connect?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
}

export interface EmployeeUpsertWithoutDebitsInput {
  update: EmployeeUpdateWithoutDebitsDataInput;
  create: EmployeeCreateWithoutDebitsInput;
}

export interface UserRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserRoleWhereInput;
  AND?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
  OR?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
  NOT?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
}

export interface ScheduleCreditUpdateOneRequiredWithoutDebitInput {
  create?: ScheduleCreditCreateWithoutDebitInput;
  update?: ScheduleCreditUpdateWithoutDebitDataInput;
  upsert?: ScheduleCreditUpsertWithoutDebitInput;
  connect?: ScheduleCreditWhereUniqueInput;
}

export interface ScheduleTimelineElementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleTimelineCategory;
  category_not?: ScheduleTimelineCategory;
  category_in?: ScheduleTimelineCategory[] | ScheduleTimelineCategory;
  category_not_in?: ScheduleTimelineCategory[] | ScheduleTimelineCategory;
  startTime?: Int;
  startTime_not?: Int;
  startTime_in?: Int[] | Int;
  startTime_not_in?: Int[] | Int;
  startTime_lt?: Int;
  startTime_lte?: Int;
  startTime_gt?: Int;
  startTime_gte?: Int;
  endTime?: Int;
  endTime_not?: Int;
  endTime_in?: Int[] | Int;
  endTime_not_in?: Int[] | Int;
  endTime_lt?: Int;
  endTime_lte?: Int;
  endTime_gt?: Int;
  endTime_gte?: Int;
  startEventRequired?: Boolean;
  startEventRequired_not?: Boolean;
  endEventRequired?: Boolean;
  endEventRequired_not?: Boolean;
  AND?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
  OR?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
  NOT?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
}

export interface ScheduleCreditUpdateWithoutDebitDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
}

export interface ScheduleCategoryConfigSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleCategoryConfigWhereInput;
  AND?:
    | ScheduleCategoryConfigSubscriptionWhereInput[]
    | ScheduleCategoryConfigSubscriptionWhereInput;
  OR?:
    | ScheduleCategoryConfigSubscriptionWhereInput[]
    | ScheduleCategoryConfigSubscriptionWhereInput;
  NOT?:
    | ScheduleCategoryConfigSubscriptionWhereInput[]
    | ScheduleCategoryConfigSubscriptionWhereInput;
}

export interface DirectCreditUpdateOneWithoutCreditsInput {
  create?: DirectCreditCreateWithoutCreditsInput;
  update?: DirectCreditUpdateWithoutCreditsDataInput;
  upsert?: DirectCreditUpsertWithoutCreditsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DirectCreditWhereUniqueInput;
}

export interface ExceptionEliminationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionEliminationWhereInput;
  AND?:
    | ExceptionEliminationSubscriptionWhereInput[]
    | ExceptionEliminationSubscriptionWhereInput;
  OR?:
    | ExceptionEliminationSubscriptionWhereInput[]
    | ExceptionEliminationSubscriptionWhereInput;
  NOT?:
    | ExceptionEliminationSubscriptionWhereInput[]
    | ExceptionEliminationSubscriptionWhereInput;
}

export interface DirectCreditUpdateWithoutCreditsDataInput {
  owner?: UserUpdateOneRequiredInput;
  employee?: EmployeeUpdateOneRequiredInput;
  description?: String;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EmployeeWhereInput;
  AND?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  OR?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  NOT?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
}

export interface EmployeeUpdateOneRequiredInput {
  create?: EmployeeCreateInput;
  update?: EmployeeUpdateDataInput;
  upsert?: EmployeeUpsertNestedInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface UserRoleUpdateInput {
  name?: String;
  description?: String;
}

export interface EmployeeUpdateDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  events?: EventUpdateManyWithoutEmployeeInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface EventSyncLogWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  from?: DateTimeInput;
  from_not?: DateTimeInput;
  from_in?: DateTimeInput[] | DateTimeInput;
  from_not_in?: DateTimeInput[] | DateTimeInput;
  from_lt?: DateTimeInput;
  from_lte?: DateTimeInput;
  from_gt?: DateTimeInput;
  from_gte?: DateTimeInput;
  to?: DateTimeInput;
  to_not?: DateTimeInput;
  to_in?: DateTimeInput[] | DateTimeInput;
  to_not_in?: DateTimeInput[] | DateTimeInput;
  to_lt?: DateTimeInput;
  to_lte?: DateTimeInput;
  to_gt?: DateTimeInput;
  to_gte?: DateTimeInput;
  AND?: EventSyncLogWhereInput[] | EventSyncLogWhereInput;
  OR?: EventSyncLogWhereInput[] | EventSyncLogWhereInput;
  NOT?: EventSyncLogWhereInput[] | EventSyncLogWhereInput;
}

export interface EmployeeUpsertNestedInput {
  update: EmployeeUpdateDataInput;
  create: EmployeeCreateInput;
}

export interface ShiftCreateInput {
  description?: String;
  employee: EmployeeCreateOneWithoutShiftsInput;
  startDate: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotCreateManyInput;
  owner: UserCreateOneInput;
}

export interface DirectCreditUpsertWithoutCreditsInput {
  update: DirectCreditUpdateWithoutCreditsDataInput;
  create: DirectCreditCreateWithoutCreditsInput;
}

export interface ScheduleOfflineElementUpdateManyMutationInput {
  category?: ScheduleOfflineCategory;
}

export interface HolidayUpdateOneInput {
  create?: HolidayCreateInput;
  update?: HolidayUpdateDataInput;
  upsert?: HolidayUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HolidayWhereUniqueInput;
}

export type ExceptionRejectionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HolidayUpdateDataInput {
  date?: DateTimeInput;
  name?: String;
}

export interface HolidayUpdateInput {
  date?: DateTimeInput;
  name?: String;
}

export interface HolidayUpsertNestedInput {
  update: HolidayUpdateDataInput;
  create: HolidayCreateInput;
}

export type HolidayWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  date?: DateTimeInput;
}>;

export interface ScheduleCreditUpsertWithoutDebitInput {
  update: ScheduleCreditUpdateWithoutDebitDataInput;
  create: ScheduleCreditCreateWithoutDebitInput;
}

export interface ExceptionCreateOneWithoutRejectionInput {
  create?: ExceptionCreateWithoutRejectionInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ScheduleDebitUpsertWithWhereUniqueWithoutExceptionInput {
  where: ScheduleDebitWhereUniqueInput;
  update: ScheduleDebitUpdateWithoutExceptionDataInput;
  create: ScheduleDebitCreateWithoutExceptionInput;
}

export interface ExceptionUpdateOneRequiredWithoutEliminationInput {
  create?: ExceptionCreateWithoutEliminationInput;
  update?: ExceptionUpdateWithoutEliminationDataInput;
  upsert?: ExceptionUpsertWithoutEliminationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ExceptionUpsertWithoutCreditsInput {
  update: ExceptionUpdateWithoutCreditsDataInput;
  create: ExceptionCreateWithoutCreditsInput;
}

export interface ExceptionUpsertWithoutCancellationInput {
  update: ExceptionUpdateWithoutCancellationDataInput;
  create: ExceptionCreateWithoutCancellationInput;
}

export interface ScheduleDebitUpdateOneWithoutCreditInput {
  create?: ScheduleDebitCreateWithoutCreditInput;
  update?: ScheduleDebitUpdateWithoutCreditDataInput;
  upsert?: ScheduleDebitUpsertWithoutCreditInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScheduleDebitWhereUniqueInput;
}

export interface ExceptionCancellationCreateInput {
  exception: ExceptionCreateOneWithoutCancellationInput;
  owner: UserCreateOneInput;
  description?: String;
}

export interface ScheduleDebitUpdateWithoutCreditDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutDebitsInput;
  category?: ScheduleOfflineCategory;
  exception?: ExceptionUpdateOneRequiredWithoutDebitsInput;
  date?: DateTimeInput;
}

export interface ExceptionCreateWithoutAuthorizationInput {
  type: ExceptionTypeEnum;
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  rejection?: ExceptionRejectionCreateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationCreateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface ScheduleDebitUpsertWithoutCreditInput {
  update: ScheduleDebitUpdateWithoutCreditDataInput;
  create: ScheduleDebitCreateWithoutCreditInput;
}

export interface EventSyncLogUpdateManyMutationInput {
  from?: DateTimeInput;
  to?: DateTimeInput;
}

export interface ScheduleCreditUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleCreditWhereUniqueInput;
  update: ScheduleCreditUpdateWithoutEmployeeDataInput;
  create: ScheduleCreditCreateWithoutEmployeeInput;
}

export interface AttendanceCycleCreateInput {
  name: String;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
}

export interface EmployeeUpsertWithoutExceptionsInput {
  update: EmployeeUpdateWithoutExceptionsDataInput;
  create: EmployeeCreateWithoutExceptionsInput;
}

export interface EventCreateManyWithoutEmployeeInput {
  create?: EventCreateWithoutEmployeeInput[] | EventCreateWithoutEmployeeInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface ScheduleCreditUpdateManyWithoutSourceExceptionInput {
  create?:
    | ScheduleCreditCreateWithoutSourceExceptionInput[]
    | ScheduleCreditCreateWithoutSourceExceptionInput;
  delete?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  disconnect?:
    | ScheduleCreditWhereUniqueInput[]
    | ScheduleCreditWhereUniqueInput;
  update?:
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceExceptionInput[]
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceExceptionInput;
  upsert?:
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceExceptionInput[]
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceExceptionInput;
}

export interface ScheduleTimelineElementCreateManyInput {
  create?:
    | ScheduleTimelineElementCreateInput[]
    | ScheduleTimelineElementCreateInput;
  connect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
}

export interface ScheduleCreditUpdateWithWhereUniqueWithoutSourceExceptionInput {
  where: ScheduleCreditWhereUniqueInput;
  data: ScheduleCreditUpdateWithoutSourceExceptionDataInput;
}

export interface DepartmentCreateManyWithoutSupervisorsInput {
  create?:
    | DepartmentCreateWithoutSupervisorsInput[]
    | DepartmentCreateWithoutSupervisorsInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
}

export interface ScheduleCreditUpdateWithoutSourceExceptionDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface ShiftSlotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShiftSlotWhereInput;
  AND?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
  OR?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
  NOT?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
}

export interface ScheduleCreditUpsertWithWhereUniqueWithoutSourceExceptionInput {
  where: ScheduleCreditWhereUniqueInput;
  update: ScheduleCreditUpdateWithoutSourceExceptionDataInput;
  create: ScheduleCreditCreateWithoutSourceExceptionInput;
}

export interface FieldOptionLabelSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FieldOptionLabelWhereInput;
  AND?:
    | FieldOptionLabelSubscriptionWhereInput[]
    | FieldOptionLabelSubscriptionWhereInput;
  OR?:
    | FieldOptionLabelSubscriptionWhereInput[]
    | FieldOptionLabelSubscriptionWhereInput;
  NOT?:
    | FieldOptionLabelSubscriptionWhereInput[]
    | FieldOptionLabelSubscriptionWhereInput;
}

export interface ExceptionUpsertWithoutDebitsInput {
  update: ExceptionUpdateWithoutDebitsDataInput;
  create: ExceptionCreateWithoutDebitsInput;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DepartmentWhereInput;
  AND?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  OR?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  NOT?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
}

export interface ScheduleDebitUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleDebitWhereUniqueInput;
  update: ScheduleDebitUpdateWithoutEmployeeDataInput;
  create: ScheduleDebitCreateWithoutEmployeeInput;
}

export interface ShiftUpdateInput {
  description?: String;
  employee?: EmployeeUpdateOneRequiredWithoutShiftsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface EmployeeUpsertWithoutCreditsInput {
  update: EmployeeUpdateWithoutCreditsDataInput;
  create: EmployeeCreateWithoutCreditsInput;
}

export interface ScheduleDebitUpdateInput {
  employee?: EmployeeUpdateOneRequiredWithoutDebitsInput;
  category?: ScheduleOfflineCategory;
  exception?: ExceptionUpdateOneRequiredWithoutDebitsInput;
  credit?: ScheduleCreditUpdateOneRequiredWithoutDebitInput;
  date?: DateTimeInput;
}

export interface ScheduleCreditUpsertNestedInput {
  update: ScheduleCreditUpdateDataInput;
  create: ScheduleCreditCreateInput;
}

export interface FieldOptionLabelUpdateInput {
  field?: String;
  value?: String;
  label?: String;
}

export interface ExceptionSlotUpsertWithWhereUniqueNestedInput {
  where: ExceptionSlotWhereUniqueInput;
  update: ExceptionSlotUpdateDataInput;
  create: ExceptionSlotCreateInput;
}

export interface AttendanceCycleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  AND?: AttendanceCycleWhereInput[] | AttendanceCycleWhereInput;
  OR?: AttendanceCycleWhereInput[] | AttendanceCycleWhereInput;
  NOT?: AttendanceCycleWhereInput[] | AttendanceCycleWhereInput;
}

export interface ExceptionUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ExceptionWhereUniqueInput;
  update: ExceptionUpdateWithoutEmployeeDataInput;
  create: ExceptionCreateWithoutEmployeeInput;
}

export interface ExceptionCancellationUpdateInput {
  exception?: ExceptionUpdateOneRequiredWithoutCancellationInput;
  owner?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface EmployeeUpsertWithWhereUniqueWithoutDepartmentInput {
  where: EmployeeWhereUniqueInput;
  update: EmployeeUpdateWithoutDepartmentDataInput;
  create: EmployeeCreateWithoutDepartmentInput;
}

export interface ExceptionUpdateManyMutationInput {
  type?: ExceptionTypeEnum;
  description?: String;
}

export interface DepartmentUpdateManyMutationInput {
  name?: String;
}

export interface EventUpdateInput {
  employee?: EmployeeUpdateOneRequiredWithoutEventsInput;
  time?: DateTimeInput;
}

export interface DirectCreditCreateInput {
  owner: UserCreateOneInput;
  employee: EmployeeCreateOneInput;
  description?: String;
  credits?: ScheduleCreditCreateManyWithoutSourceDirectInput;
}

export interface ScheduleOfflineElementCreateOneInput {
  create?: ScheduleOfflineElementCreateInput;
  connect?: ScheduleOfflineElementWhereUniqueInput;
}

export interface ScheduleCreditCreateManyWithoutSourceDirectInput {
  create?:
    | ScheduleCreditCreateWithoutSourceDirectInput[]
    | ScheduleCreditCreateWithoutSourceDirectInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
}

export interface ScheduleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isPreset?: Boolean;
  isPreset_not?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  systemScheduleIdentifier_not?: SystemScheduleIdentifierEnum;
  systemScheduleIdentifier_in?:
    | SystemScheduleIdentifierEnum[]
    | SystemScheduleIdentifierEnum;
  systemScheduleIdentifier_not_in?:
    | SystemScheduleIdentifierEnum[]
    | SystemScheduleIdentifierEnum;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  baseTime?: Int;
  baseTime_not?: Int;
  baseTime_in?: Int[] | Int;
  baseTime_not_in?: Int[] | Int;
  baseTime_lt?: Int;
  baseTime_lte?: Int;
  baseTime_gt?: Int;
  baseTime_gte?: Int;
  innerBound?: Int;
  innerBound_not?: Int;
  innerBound_in?: Int[] | Int;
  innerBound_not_in?: Int[] | Int;
  innerBound_lt?: Int;
  innerBound_lte?: Int;
  innerBound_gt?: Int;
  innerBound_gte?: Int;
  outerBound?: Int;
  outerBound_not?: Int;
  outerBound_in?: Int[] | Int;
  outerBound_not_in?: Int[] | Int;
  outerBound_lt?: Int;
  outerBound_lte?: Int;
  outerBound_gt?: Int;
  outerBound_gte?: Int;
  timeline_every?: ScheduleTimelineElementWhereInput;
  timeline_some?: ScheduleTimelineElementWhereInput;
  timeline_none?: ScheduleTimelineElementWhereInput;
  restline_every?: ScheduleRestlineElementWhereInput;
  restline_some?: ScheduleRestlineElementWhereInput;
  restline_none?: ScheduleRestlineElementWhereInput;
  offline1?: ScheduleOfflineElementWhereInput;
  offline2?: ScheduleOfflineElementWhereInput;
  AND?: ScheduleWhereInput[] | ScheduleWhereInput;
  OR?: ScheduleWhereInput[] | ScheduleWhereInput;
  NOT?: ScheduleWhereInput[] | ScheduleWhereInput;
}

export interface ScheduleCreditCreateWithoutSourceDirectInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface ShiftSlotUpdateManyMutationInput {
  index?: Int;
}

export interface DirectCreditUpdateInput {
  owner?: UserUpdateOneRequiredInput;
  employee?: EmployeeUpdateOneRequiredInput;
  description?: String;
  credits?: ScheduleCreditUpdateManyWithoutSourceDirectInput;
}

export interface ScheduleUpdateManyMutationInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime?: Int;
  innerBound?: Int;
  outerBound?: Int;
}

export interface ScheduleCreditUpdateManyWithoutSourceDirectInput {
  create?:
    | ScheduleCreditCreateWithoutSourceDirectInput[]
    | ScheduleCreditCreateWithoutSourceDirectInput;
  delete?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  disconnect?:
    | ScheduleCreditWhereUniqueInput[]
    | ScheduleCreditWhereUniqueInput;
  update?:
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceDirectInput[]
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceDirectInput;
  upsert?:
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceDirectInput[]
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceDirectInput;
}

export interface ExceptionCreateOneWithoutEliminationInput {
  create?: ExceptionCreateWithoutEliminationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface ScheduleCreditUpdateWithWhereUniqueWithoutSourceDirectInput {
  where: ScheduleCreditWhereUniqueInput;
  data: ScheduleCreditUpdateWithoutSourceDirectDataInput;
}

export interface EventUpdateManyMutationInput {
  time?: DateTimeInput;
}

export interface ScheduleCreditUpdateWithoutSourceDirectDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface ExceptionCreateManyWithoutEmployeeInput {
  create?:
    | ExceptionCreateWithoutEmployeeInput[]
    | ExceptionCreateWithoutEmployeeInput;
  connect?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
}

export interface ScheduleCreditUpsertWithWhereUniqueWithoutSourceDirectInput {
  where: ScheduleCreditWhereUniqueInput;
  update: ScheduleCreditUpdateWithoutSourceDirectDataInput;
  create: ScheduleCreditCreateWithoutSourceDirectInput;
}

export interface ScheduleTimelineElementUpdateInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface EventCreateInput {
  employee: EmployeeCreateOneWithoutEventsInput;
  time: DateTimeInput;
}

export interface EmployeeUpdateManyMutationInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
}

export interface EmployeeUpdateInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  events?: EventUpdateManyWithoutEmployeeInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface DirectCreditUpdateManyMutationInput {
  description?: String;
}

export interface ExceptionUpdateOneRequiredWithoutRejectionInput {
  create?: ExceptionCreateWithoutRejectionInput;
  update?: ExceptionUpdateWithoutRejectionDataInput;
  upsert?: ExceptionUpsertWithoutRejectionInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  departments_every?: DepartmentWhereInput;
  departments_some?: DepartmentWhereInput;
  departments_none?: DepartmentWhereInput;
  roles_every?: UserRoleWhereInput;
  roles_some?: UserRoleWhereInput;
  roles_none?: UserRoleWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ShiftSlotCreateManyInput {
  create?: ShiftSlotCreateInput[] | ShiftSlotCreateInput;
  connect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
}

export interface ExceptionUpdateWithoutAuthorizationDataInput {
  type?: ExceptionTypeEnum;
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  rejection?: ExceptionRejectionUpdateOneWithoutExceptionInput;
  cancellation?: ExceptionCancellationUpdateOneWithoutExceptionInput;
  elimination?: ExceptionEliminationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserRolePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface UserRolePreviousValuesPromise
  extends Promise<UserRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface UserRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Employee {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeOutput;
  nationality?: String;
  jubilado: Boolean;
  personaConDiscapacidad: Boolean;
  tutorPersonaConDiscapacidad: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nameFirst: () => Promise<String>;
  nameMiddle: () => Promise<String>;
  namePaternal: () => Promise<String>;
  nameMaternal: () => Promise<String>;
  documentType: () => Promise<EmployeeDocumentTypeEnum>;
  documentNumber: () => Promise<String>;
  sex: () => Promise<EmployeeSexEnum>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  nationality: () => Promise<String>;
  jubilado: () => Promise<Boolean>;
  personaConDiscapacidad: () => Promise<Boolean>;
  tutorPersonaConDiscapacidad: () => Promise<Boolean>;
  cajaDeSalud: () => Promise<EmployeeCajaDeSaludEnum>;
  aportaAFP: () => Promise<Boolean>;
  AFP: () => Promise<EmployeeAFPEnum>;
  cargo: () => Promise<String>;
  zkTimePin: () => Promise<Int>;
  department: <T = DepartmentPromise>() => T;
  events: <T = FragmentableArray<Event>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  shifts: <T = FragmentableArray<Shift>>(
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exceptions: <T = FragmentableArray<Exception>>(
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  credits: <T = FragmentableArray<ScheduleCredit>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = FragmentableArray<ScheduleDebit>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameMiddle: () => Promise<AsyncIterator<String>>;
  namePaternal: () => Promise<AsyncIterator<String>>;
  nameMaternal: () => Promise<AsyncIterator<String>>;
  documentType: () => Promise<AsyncIterator<EmployeeDocumentTypeEnum>>;
  documentNumber: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<EmployeeSexEnum>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  nationality: () => Promise<AsyncIterator<String>>;
  jubilado: () => Promise<AsyncIterator<Boolean>>;
  personaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  tutorPersonaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  cajaDeSalud: () => Promise<AsyncIterator<EmployeeCajaDeSaludEnum>>;
  aportaAFP: () => Promise<AsyncIterator<Boolean>>;
  AFP: () => Promise<AsyncIterator<EmployeeAFPEnum>>;
  cargo: () => Promise<AsyncIterator<String>>;
  zkTimePin: () => Promise<AsyncIterator<Int>>;
  department: <T = DepartmentSubscription>() => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  shifts: <T = Promise<AsyncIterator<ShiftSubscription>>>(
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exceptions: <T = Promise<AsyncIterator<ExceptionSubscription>>>(
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  credits: <T = Promise<AsyncIterator<ScheduleCreditSubscription>>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = Promise<AsyncIterator<ScheduleDebitSubscription>>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EmployeeEdge {
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface EmployeeConnection {}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface UserRoleEdge {
  cursor: String;
}

export interface UserRoleEdgePromise
  extends Promise<UserRoleEdge>,
    Fragmentable {
  node: <T = UserRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRoleEdgeSubscription
  extends Promise<AsyncIterator<UserRoleEdge>>,
    Fragmentable {
  node: <T = UserRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDirectCredit {
  count: Int;
}

export interface AggregateDirectCreditPromise
  extends Promise<AggregateDirectCredit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDirectCreditSubscription
  extends Promise<AsyncIterator<AggregateDirectCredit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttendanceCycle {
  id: ID_Output;
  name: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface AttendanceCyclePromise
  extends Promise<AttendanceCycle>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface AttendanceCycleSubscription
  extends Promise<AsyncIterator<AttendanceCycle>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AttendanceCycleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AttendanceCycleSubscriptionPayloadPromise
  extends Promise<AttendanceCycleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttendanceCyclePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttendanceCyclePreviousValuesPromise>() => T;
}

export interface AttendanceCycleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttendanceCycleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttendanceCycleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttendanceCyclePreviousValuesSubscription>() => T;
}

export interface ShiftSlotEdge {
  cursor: String;
}

export interface ShiftSlotEdgePromise
  extends Promise<ShiftSlotEdge>,
    Fragmentable {
  node: <T = ShiftSlotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShiftSlotEdgeSubscription
  extends Promise<AsyncIterator<ShiftSlotEdge>>,
    Fragmentable {
  node: <T = ShiftSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttendanceCyclePreviousValues {
  id: ID_Output;
  name: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface AttendanceCyclePreviousValuesPromise
  extends Promise<AttendanceCyclePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface AttendanceCyclePreviousValuesSubscription
  extends Promise<AsyncIterator<AttendanceCyclePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateShift {
  count: Int;
}

export interface AggregateShiftPromise
  extends Promise<AggregateShift>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShiftSubscription
  extends Promise<AsyncIterator<AggregateShift>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DirectCreditEdge {
  cursor: String;
}

export interface DirectCreditEdgePromise
  extends Promise<DirectCreditEdge>,
    Fragmentable {
  node: <T = DirectCreditPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DirectCreditEdgeSubscription
  extends Promise<AsyncIterator<DirectCreditEdge>>,
    Fragmentable {
  node: <T = DirectCreditSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ShiftConnection {}

export interface ShiftConnectionPromise
  extends Promise<ShiftConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShiftEdge>>() => T;
  aggregate: <T = AggregateShiftPromise>() => T;
}

export interface ShiftConnectionSubscription
  extends Promise<AsyncIterator<ShiftConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShiftEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShiftSubscription>() => T;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface ScheduleTimelineElementEdge {
  cursor: String;
}

export interface ScheduleTimelineElementEdgePromise
  extends Promise<ScheduleTimelineElementEdge>,
    Fragmentable {
  node: <T = ScheduleTimelineElementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleTimelineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementEdge>>,
    Fragmentable {
  node: <T = ScheduleTimelineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScheduleRestlineElement {
  count: Int;
}

export interface AggregateScheduleRestlineElementPromise
  extends Promise<AggregateScheduleRestlineElement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleRestlineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleRestlineElement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DirectCreditConnection {}

export interface DirectCreditConnectionPromise
  extends Promise<DirectCreditConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DirectCreditEdge>>() => T;
  aggregate: <T = AggregateDirectCreditPromise>() => T;
}

export interface DirectCreditConnectionSubscription
  extends Promise<AsyncIterator<DirectCreditConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DirectCreditEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDirectCreditSubscription>() => T;
}

export interface ScheduleRestlineElementConnection {}

export interface ScheduleRestlineElementConnectionPromise
  extends Promise<ScheduleRestlineElementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleRestlineElementEdge>>() => T;
  aggregate: <T = AggregateScheduleRestlineElementPromise>() => T;
}

export interface ScheduleRestlineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleRestlineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleRestlineElementSubscription>() => T;
}

export interface DirectCreditSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DirectCreditSubscriptionPayloadPromise
  extends Promise<DirectCreditSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DirectCreditPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DirectCreditPreviousValuesPromise>() => T;
}

export interface DirectCreditSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DirectCreditSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DirectCreditSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DirectCreditPreviousValuesSubscription>() => T;
}

export interface ScheduleOfflineElementEdge {
  cursor: String;
}

export interface ScheduleOfflineElementEdgePromise
  extends Promise<ScheduleOfflineElementEdge>,
    Fragmentable {
  node: <T = ScheduleOfflineElementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleOfflineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementEdge>>,
    Fragmentable {
  node: <T = ScheduleOfflineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScheduleOfflineElement {
  count: Int;
}

export interface AggregateScheduleOfflineElementPromise
  extends Promise<AggregateScheduleOfflineElement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleOfflineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleOfflineElement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Shift {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface ShiftPromise extends Promise<Shift>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  employee: <T = EmployeePromise>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  slots: <T = FragmentableArray<ShiftSlot>>(
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserPromise>() => T;
}

export interface ShiftSubscription
  extends Promise<AsyncIterator<Shift>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  employee: <T = EmployeeSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  slots: <T = Promise<AsyncIterator<ShiftSlotSubscription>>>(
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserSubscription>() => T;
}

export interface ScheduleOfflineElementConnection {}

export interface ScheduleOfflineElementConnectionPromise
  extends Promise<ScheduleOfflineElementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleOfflineElementEdge>>() => T;
  aggregate: <T = AggregateScheduleOfflineElementPromise>() => T;
}

export interface ScheduleOfflineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleOfflineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleOfflineElementSubscription>() => T;
}

export interface DirectCreditPreviousValues {
  id: ID_Output;
  description?: String;
}

export interface DirectCreditPreviousValuesPromise
  extends Promise<DirectCreditPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
}

export interface DirectCreditPreviousValuesSubscription
  extends Promise<AsyncIterator<DirectCreditPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScheduleDebit {
  count: Int;
}

export interface AggregateScheduleDebitPromise
  extends Promise<AggregateScheduleDebit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleDebitSubscription
  extends Promise<AsyncIterator<AggregateScheduleDebit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleDebitConnection {}

export interface ScheduleDebitConnectionPromise
  extends Promise<ScheduleDebitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleDebitEdge>>() => T;
  aggregate: <T = AggregateScheduleDebitPromise>() => T;
}

export interface ScheduleDebitConnectionSubscription
  extends Promise<AsyncIterator<ScheduleDebitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleDebitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleDebitSubscription>() => T;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleCreditEdge {
  cursor: String;
}

export interface ScheduleCreditEdgePromise
  extends Promise<ScheduleCreditEdge>,
    Fragmentable {
  node: <T = ScheduleCreditPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleCreditEdgeSubscription
  extends Promise<AsyncIterator<ScheduleCreditEdge>>,
    Fragmentable {
  node: <T = ScheduleCreditSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface AggregateScheduleCategoryConfig {
  count: Int;
}

export interface AggregateScheduleCategoryConfigPromise
  extends Promise<AggregateScheduleCategoryConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleCategoryConfigSubscription
  extends Promise<AsyncIterator<AggregateScheduleCategoryConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeOutput;
  nationality?: String;
  jubilado: Boolean;
  personaConDiscapacidad: Boolean;
  tutorPersonaConDiscapacidad: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nameFirst: () => Promise<String>;
  nameMiddle: () => Promise<String>;
  namePaternal: () => Promise<String>;
  nameMaternal: () => Promise<String>;
  documentType: () => Promise<EmployeeDocumentTypeEnum>;
  documentNumber: () => Promise<String>;
  sex: () => Promise<EmployeeSexEnum>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  nationality: () => Promise<String>;
  jubilado: () => Promise<Boolean>;
  personaConDiscapacidad: () => Promise<Boolean>;
  tutorPersonaConDiscapacidad: () => Promise<Boolean>;
  cajaDeSalud: () => Promise<EmployeeCajaDeSaludEnum>;
  aportaAFP: () => Promise<Boolean>;
  AFP: () => Promise<EmployeeAFPEnum>;
  cargo: () => Promise<String>;
  zkTimePin: () => Promise<Int>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameMiddle: () => Promise<AsyncIterator<String>>;
  namePaternal: () => Promise<AsyncIterator<String>>;
  nameMaternal: () => Promise<AsyncIterator<String>>;
  documentType: () => Promise<AsyncIterator<EmployeeDocumentTypeEnum>>;
  documentNumber: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<EmployeeSexEnum>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  nationality: () => Promise<AsyncIterator<String>>;
  jubilado: () => Promise<AsyncIterator<Boolean>>;
  personaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  tutorPersonaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  cajaDeSalud: () => Promise<AsyncIterator<EmployeeCajaDeSaludEnum>>;
  aportaAFP: () => Promise<AsyncIterator<Boolean>>;
  AFP: () => Promise<AsyncIterator<EmployeeAFPEnum>>;
  cargo: () => Promise<AsyncIterator<String>>;
  zkTimePin: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleCategoryConfigConnection {}

export interface ScheduleCategoryConfigConnectionPromise
  extends Promise<ScheduleCategoryConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleCategoryConfigEdge>>() => T;
  aggregate: <T = AggregateScheduleCategoryConfigPromise>() => T;
}

export interface ScheduleCategoryConfigConnectionSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleCategoryConfigEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleCategoryConfigSubscription>() => T;
}

export interface DepartmentEdge {
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCategoryConfig {
  id: ID_Output;
  category?: ScheduleCategory;
  backgroundColor: String;
  foregroundColor: String;
  description?: String;
}

export interface ScheduleCategoryConfigPromise
  extends Promise<ScheduleCategoryConfig>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleCategory>;
  backgroundColor: () => Promise<String>;
  foregroundColor: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ScheduleCategoryConfigSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleCategory>>;
  backgroundColor: () => Promise<AsyncIterator<String>>;
  foregroundColor: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface ScheduleEdge {
  cursor: String;
}

export interface ScheduleEdgePromise
  extends Promise<ScheduleEdge>,
    Fragmentable {
  node: <T = SchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleEdgeSubscription
  extends Promise<AsyncIterator<ScheduleEdge>>,
    Fragmentable {
  node: <T = ScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  time: DateTimeOutput;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  time: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  time: DateTimeOutput;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  employee: <T = EmployeePromise>() => T;
  time: () => Promise<DateTimeOutput>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  employee: <T = EmployeeSubscription>() => T;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DepartmentConnection {}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface HolidayEdge {
  cursor: String;
}

export interface HolidayEdgePromise extends Promise<HolidayEdge>, Fragmentable {
  node: <T = HolidayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HolidayEdgeSubscription
  extends Promise<AsyncIterator<HolidayEdge>>,
    Fragmentable {
  node: <T = HolidaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventSyncLogSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EventSyncLogSubscriptionPayloadPromise
  extends Promise<EventSyncLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventSyncLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventSyncLogPreviousValuesPromise>() => T;
}

export interface EventSyncLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSyncLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSyncLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventSyncLogPreviousValuesSubscription>() => T;
}

export interface AttendanceCycleConnection {}

export interface AttendanceCycleConnectionPromise
  extends Promise<AttendanceCycleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttendanceCycleEdge>>() => T;
  aggregate: <T = AggregateAttendanceCyclePromise>() => T;
}

export interface AttendanceCycleConnectionSubscription
  extends Promise<AsyncIterator<AttendanceCycleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttendanceCycleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttendanceCycleSubscription>() => T;
}

export interface EventSyncLogPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  from: DateTimeOutput;
  to: DateTimeOutput;
}

export interface EventSyncLogPreviousValuesPromise
  extends Promise<EventSyncLogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  from: () => Promise<DateTimeOutput>;
  to: () => Promise<DateTimeOutput>;
}

export interface EventSyncLogPreviousValuesSubscription
  extends Promise<AsyncIterator<EventSyncLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  from: () => Promise<AsyncIterator<DateTimeOutput>>;
  to: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FieldOptionLabelEdge {
  cursor: String;
}

export interface FieldOptionLabelEdgePromise
  extends Promise<FieldOptionLabelEdge>,
    Fragmentable {
  node: <T = FieldOptionLabelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldOptionLabelEdgeSubscription
  extends Promise<AsyncIterator<FieldOptionLabelEdge>>,
    Fragmentable {
  node: <T = FieldOptionLabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionElimination {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionEliminationPromise
  extends Promise<ExceptionElimination>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  exception: <T = ExceptionPromise>() => T;
  owner: <T = UserPromise>() => T;
  description: () => Promise<String>;
}

export interface ExceptionEliminationSubscription
  extends Promise<AsyncIterator<ExceptionElimination>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  exception: <T = ExceptionSubscription>() => T;
  owner: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionSubscriptionPayloadPromise
  extends Promise<ExceptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionPreviousValuesPromise>() => T;
}

export interface ExceptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionPreviousValuesSubscription>() => T;
}

export interface AggregateExceptionSlot {
  count: Int;
}

export interface AggregateExceptionSlotPromise
  extends Promise<AggregateExceptionSlot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionSlotSubscription
  extends Promise<AsyncIterator<AggregateExceptionSlot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionPreviousValues {
  id: ID_Output;
  type: ExceptionTypeEnum;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionPreviousValuesPromise
  extends Promise<ExceptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ExceptionTypeEnum>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
}

export interface ExceptionPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ExceptionTypeEnum>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionSlotConnection {}

export interface ExceptionSlotConnectionPromise
  extends Promise<ExceptionSlotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExceptionSlotEdge>>() => T;
  aggregate: <T = AggregateExceptionSlotPromise>() => T;
}

export interface ExceptionSlotConnectionSubscription
  extends Promise<AsyncIterator<ExceptionSlotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExceptionSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExceptionSlotSubscription>() => T;
}

export interface ExceptionCancellation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionCancellationPromise
  extends Promise<ExceptionCancellation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  exception: <T = ExceptionPromise>() => T;
  owner: <T = UserPromise>() => T;
  description: () => Promise<String>;
}

export interface ExceptionCancellationSubscription
  extends Promise<AsyncIterator<ExceptionCancellation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  exception: <T = ExceptionSubscription>() => T;
  owner: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionRejectionEdge {
  cursor: String;
}

export interface ExceptionRejectionEdgePromise
  extends Promise<ExceptionRejectionEdge>,
    Fragmentable {
  node: <T = ExceptionRejectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionRejectionEdgeSubscription
  extends Promise<AsyncIterator<ExceptionRejectionEdge>>,
    Fragmentable {
  node: <T = ExceptionRejectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionAuthorizationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionAuthorizationSubscriptionPayloadPromise
  extends Promise<ExceptionAuthorizationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionAuthorizationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionAuthorizationPreviousValuesPromise>() => T;
}

export interface ExceptionAuthorizationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionAuthorizationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionAuthorizationPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionAuthorizationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionAuthorizationPreviousValuesPromise
  extends Promise<ExceptionAuthorizationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
}

export interface ExceptionAuthorizationPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionEliminationEdge {
  cursor: String;
}

export interface ExceptionEliminationEdgePromise
  extends Promise<ExceptionEliminationEdge>,
    Fragmentable {
  node: <T = ExceptionEliminationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionEliminationEdgeSubscription
  extends Promise<AsyncIterator<ExceptionEliminationEdge>>,
    Fragmentable {
  node: <T = ExceptionEliminationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionAuthorization {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionAuthorizationPromise
  extends Promise<ExceptionAuthorization>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  exception: <T = ExceptionPromise>() => T;
  owner: <T = UserPromise>() => T;
  description: () => Promise<String>;
}

export interface ExceptionAuthorizationSubscription
  extends Promise<AsyncIterator<ExceptionAuthorization>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  exception: <T = ExceptionSubscription>() => T;
  owner: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AttendanceCycleEdge {
  cursor: String;
}

export interface AttendanceCycleEdgePromise
  extends Promise<AttendanceCycleEdge>,
    Fragmentable {
  node: <T = AttendanceCyclePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttendanceCycleEdgeSubscription
  extends Promise<AsyncIterator<AttendanceCycleEdge>>,
    Fragmentable {
  node: <T = AttendanceCycleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionCancellationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionCancellationSubscriptionPayloadPromise
  extends Promise<ExceptionCancellationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionCancellationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionCancellationPreviousValuesPromise>() => T;
}

export interface ExceptionCancellationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionCancellationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionCancellationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionCancellationPreviousValuesSubscription>() => T;
}

export interface ExceptionCancellationEdge {
  cursor: String;
}

export interface ExceptionCancellationEdgePromise
  extends Promise<ExceptionCancellationEdge>,
    Fragmentable {
  node: <T = ExceptionCancellationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionCancellationEdgeSubscription
  extends Promise<AsyncIterator<ExceptionCancellationEdge>>,
    Fragmentable {
  node: <T = ExceptionCancellationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionCancellationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionCancellationPreviousValuesPromise
  extends Promise<ExceptionCancellationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
}

export interface ExceptionCancellationPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionCancellationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAttendanceCycle {
  count: Int;
}

export interface AggregateAttendanceCyclePromise
  extends Promise<AggregateAttendanceCycle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttendanceCycleSubscription
  extends Promise<AsyncIterator<AggregateAttendanceCycle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionRejection {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionRejectionPromise
  extends Promise<ExceptionRejection>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  exception: <T = ExceptionPromise>() => T;
  owner: <T = UserPromise>() => T;
  description: () => Promise<String>;
}

export interface ExceptionRejectionSubscription
  extends Promise<AsyncIterator<ExceptionRejection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  exception: <T = ExceptionSubscription>() => T;
  owner: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionAuthorizationEdge {
  cursor: String;
}

export interface ExceptionAuthorizationEdgePromise
  extends Promise<ExceptionAuthorizationEdge>,
    Fragmentable {
  node: <T = ExceptionAuthorizationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionAuthorizationEdgeSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationEdge>>,
    Fragmentable {
  node: <T = ExceptionAuthorizationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionEliminationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionEliminationSubscriptionPayloadPromise
  extends Promise<ExceptionEliminationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionEliminationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionEliminationPreviousValuesPromise>() => T;
}

export interface ExceptionEliminationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionEliminationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionEliminationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionEliminationPreviousValuesSubscription>() => T;
}

export interface AggregateException {
  count: Int;
}

export interface AggregateExceptionPromise
  extends Promise<AggregateException>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionSubscription
  extends Promise<AsyncIterator<AggregateException>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionEliminationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionEliminationPreviousValuesPromise
  extends Promise<ExceptionEliminationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
}

export interface ExceptionEliminationPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionEliminationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionConnection {}

export interface ExceptionConnectionPromise
  extends Promise<ExceptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExceptionEdge>>() => T;
  aggregate: <T = AggregateExceptionPromise>() => T;
}

export interface ExceptionConnectionSubscription
  extends Promise<AsyncIterator<ExceptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExceptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExceptionSubscription>() => T;
}

export interface ScheduleDebit {
  id: ID_Output;
  category: ScheduleOfflineCategory;
  date: DateTimeOutput;
}

export interface ScheduleDebitPromise
  extends Promise<ScheduleDebit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  employee: <T = EmployeePromise>() => T;
  category: () => Promise<ScheduleOfflineCategory>;
  exception: <T = ExceptionPromise>() => T;
  credit: <T = ScheduleCreditPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface ScheduleDebitSubscription
  extends Promise<AsyncIterator<ScheduleDebit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  employee: <T = EmployeeSubscription>() => T;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
  exception: <T = ExceptionSubscription>() => T;
  credit: <T = ScheduleCreditSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventSyncLogEdge {
  cursor: String;
}

export interface EventSyncLogEdgePromise
  extends Promise<EventSyncLogEdge>,
    Fragmentable {
  node: <T = EventSyncLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventSyncLogEdgeSubscription
  extends Promise<AsyncIterator<EventSyncLogEdge>>,
    Fragmentable {
  node: <T = EventSyncLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionRejectionSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionRejectionSubscriptionPayloadPromise
  extends Promise<ExceptionRejectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionRejectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionRejectionPreviousValuesPromise>() => T;
}

export interface ExceptionRejectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionRejectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionRejectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionRejectionPreviousValuesSubscription>() => T;
}

export interface Department {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  subordinates: <T = FragmentableArray<Employee>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  supervisors: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  subordinates: <T = Promise<AsyncIterator<EmployeeSubscription>>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  supervisors: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExceptionRejectionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionRejectionPreviousValuesPromise
  extends Promise<ExceptionRejectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
}

export interface ExceptionRejectionPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionRejectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Holiday {
  id: ID_Output;
  date: DateTimeOutput;
  name: String;
}

export interface HolidayPromise extends Promise<Holiday>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface HolidaySubscription
  extends Promise<AsyncIterator<Holiday>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface EventConnection {}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface ExceptionSlotSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionSlotSubscriptionPayloadPromise
  extends Promise<ExceptionSlotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionSlotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionSlotPreviousValuesPromise>() => T;
}

export interface ExceptionSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionSlotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionSlotPreviousValuesSubscription>() => T;
}

export interface AggregateUserRole {
  count: Int;
}

export interface AggregateUserRolePromise
  extends Promise<AggregateUserRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRoleSubscription
  extends Promise<AsyncIterator<AggregateUserRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionSlotPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface ExceptionSlotPreviousValuesPromise
  extends Promise<ExceptionSlotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
}

export interface ExceptionSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionSlotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DirectCredit {
  id: ID_Output;
  description?: String;
}

export interface DirectCreditPromise
  extends Promise<DirectCredit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  employee: <T = EmployeePromise>() => T;
  description: () => Promise<String>;
  credits: <T = FragmentableArray<ScheduleCredit>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DirectCreditSubscription
  extends Promise<AsyncIterator<DirectCredit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  employee: <T = EmployeeSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  credits: <T = Promise<AsyncIterator<ScheduleCreditSubscription>>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ShiftSlotConnection {}

export interface ShiftSlotConnectionPromise
  extends Promise<ShiftSlotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShiftSlotEdge>>() => T;
  aggregate: <T = AggregateShiftSlotPromise>() => T;
}

export interface ShiftSlotConnectionSubscription
  extends Promise<AsyncIterator<ShiftSlotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShiftSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShiftSlotSubscription>() => T;
}

export interface FieldOptionLabelSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FieldOptionLabelSubscriptionPayloadPromise
  extends Promise<FieldOptionLabelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldOptionLabelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldOptionLabelPreviousValuesPromise>() => T;
}

export interface FieldOptionLabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldOptionLabelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldOptionLabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldOptionLabelPreviousValuesSubscription>() => T;
}

export interface AggregateScheduleTimelineElement {
  count: Int;
}

export interface AggregateScheduleTimelineElementPromise
  extends Promise<AggregateScheduleTimelineElement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleTimelineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleTimelineElement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldOptionLabelPreviousValues {
  id: ID_Output;
  field: String;
  value: String;
  label?: String;
}

export interface FieldOptionLabelPreviousValuesPromise
  extends Promise<FieldOptionLabelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<String>;
  value: () => Promise<String>;
  label: () => Promise<String>;
}

export interface FieldOptionLabelPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldOptionLabelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleRestlineElementEdge {
  cursor: String;
}

export interface ScheduleRestlineElementEdgePromise
  extends Promise<ScheduleRestlineElementEdge>,
    Fragmentable {
  node: <T = ScheduleRestlineElementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleRestlineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementEdge>>,
    Fragmentable {
  node: <T = ScheduleRestlineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCredit {
  id: ID_Output;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceDate: DateTimeOutput;
}

export interface ScheduleCreditPromise
  extends Promise<ScheduleCredit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  employee: <T = EmployeePromise>() => T;
  category: () => Promise<ScheduleOfflineCategory>;
  sourceType: () => Promise<ScheduleCreditSourceEnum>;
  sourceException: <T = ExceptionPromise>() => T;
  sourceDirect: <T = DirectCreditPromise>() => T;
  sourceConcurentHoliday: <T = HolidayPromise>() => T;
  sourceDate: () => Promise<DateTimeOutput>;
  debit: <T = ScheduleDebitPromise>() => T;
}

export interface ScheduleCreditSubscription
  extends Promise<AsyncIterator<ScheduleCredit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  employee: <T = EmployeeSubscription>() => T;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
  sourceType: () => Promise<AsyncIterator<ScheduleCreditSourceEnum>>;
  sourceException: <T = ExceptionSubscription>() => T;
  sourceDirect: <T = DirectCreditSubscription>() => T;
  sourceConcurentHoliday: <T = HolidaySubscription>() => T;
  sourceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  debit: <T = ScheduleDebitSubscription>() => T;
}

export interface AggregateScheduleCredit {
  count: Int;
}

export interface AggregateScheduleCreditPromise
  extends Promise<AggregateScheduleCredit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleCreditSubscription
  extends Promise<AsyncIterator<AggregateScheduleCredit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HolidaySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HolidaySubscriptionPayloadPromise
  extends Promise<HolidaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HolidayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HolidayPreviousValuesPromise>() => T;
}

export interface HolidaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HolidaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HolidaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HolidayPreviousValuesSubscription>() => T;
}

export interface ScheduleCategoryConfigEdge {
  cursor: String;
}

export interface ScheduleCategoryConfigEdgePromise
  extends Promise<ScheduleCategoryConfigEdge>,
    Fragmentable {
  node: <T = ScheduleCategoryConfigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleCategoryConfigEdgeSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigEdge>>,
    Fragmentable {
  node: <T = ScheduleCategoryConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HolidayPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  name: String;
}

export interface HolidayPreviousValuesPromise
  extends Promise<HolidayPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface HolidayPreviousValuesSubscription
  extends Promise<AsyncIterator<HolidayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchedule {
  count: Int;
}

export interface AggregateSchedulePromise
  extends Promise<AggregateSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleSubscription
  extends Promise<AsyncIterator<AggregateSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionSlot {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface ExceptionSlotPromise
  extends Promise<ExceptionSlot>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  schedule: <T = SchedulePromise>() => T;
  date: () => Promise<DateTimeOutput>;
  source1: <T = ScheduleCreditPromise>() => T;
  source2: <T = ScheduleCreditPromise>() => T;
}

export interface ExceptionSlotSubscription
  extends Promise<AsyncIterator<ExceptionSlot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  schedule: <T = ScheduleSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  source1: <T = ScheduleCreditSubscription>() => T;
  source2: <T = ScheduleCreditSubscription>() => T;
}

export interface AggregateHoliday {
  count: Int;
}

export interface AggregateHolidayPromise
  extends Promise<AggregateHoliday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHolidaySubscription
  extends Promise<AsyncIterator<AggregateHoliday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleSubscriptionPayloadPromise
  extends Promise<ScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchedulePreviousValuesPromise>() => T;
}

export interface ScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchedulePreviousValuesSubscription>() => T;
}

export interface AggregateFieldOptionLabel {
  count: Int;
}

export interface AggregateFieldOptionLabelPromise
  extends Promise<AggregateFieldOptionLabel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldOptionLabelSubscription
  extends Promise<AsyncIterator<AggregateFieldOptionLabel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchedulePreviousValues {
  id: ID_Output;
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  baseTime: Int;
  innerBound?: Int;
  outerBound?: Int;
}

export interface SchedulePreviousValuesPromise
  extends Promise<SchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPreset: () => Promise<Boolean>;
  systemScheduleIdentifier: () => Promise<SystemScheduleIdentifierEnum>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  baseTime: () => Promise<Int>;
  innerBound: () => Promise<Int>;
  outerBound: () => Promise<Int>;
}

export interface SchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPreset: () => Promise<AsyncIterator<Boolean>>;
  systemScheduleIdentifier: () => Promise<
    AsyncIterator<SystemScheduleIdentifierEnum>
  >;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  baseTime: () => Promise<AsyncIterator<Int>>;
  innerBound: () => Promise<AsyncIterator<Int>>;
  outerBound: () => Promise<AsyncIterator<Int>>;
}

export interface FieldOptionLabel {
  id: ID_Output;
  field: String;
  value: String;
  label?: String;
}

export interface FieldOptionLabelPromise
  extends Promise<FieldOptionLabel>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<String>;
  value: () => Promise<String>;
  label: () => Promise<String>;
}

export interface FieldOptionLabelSubscription
  extends Promise<AsyncIterator<FieldOptionLabel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface Exception {
  id: ID_Output;
  type: ExceptionTypeEnum;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionPromise extends Promise<Exception>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ExceptionTypeEnum>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  employee: <T = EmployeePromise>() => T;
  description: () => Promise<String>;
  slots: <T = FragmentableArray<ExceptionSlot>>(
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  rejection: <T = ExceptionRejectionPromise>() => T;
  authorization: <T = ExceptionAuthorizationPromise>() => T;
  cancellation: <T = ExceptionCancellationPromise>() => T;
  elimination: <T = ExceptionEliminationPromise>() => T;
  owner: <T = UserPromise>() => T;
  credits: <T = FragmentableArray<ScheduleCredit>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = FragmentableArray<ScheduleDebit>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExceptionSubscription
  extends Promise<AsyncIterator<Exception>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ExceptionTypeEnum>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  employee: <T = EmployeeSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  slots: <T = Promise<AsyncIterator<ExceptionSlotSubscription>>>(
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  rejection: <T = ExceptionRejectionSubscription>() => T;
  authorization: <T = ExceptionAuthorizationSubscription>() => T;
  cancellation: <T = ExceptionCancellationSubscription>() => T;
  elimination: <T = ExceptionEliminationSubscription>() => T;
  owner: <T = UserSubscription>() => T;
  credits: <T = Promise<AsyncIterator<ScheduleCreditSubscription>>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = Promise<AsyncIterator<ScheduleDebitSubscription>>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateExceptionRejection {
  count: Int;
}

export interface AggregateExceptionRejectionPromise
  extends Promise<AggregateExceptionRejection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionRejectionSubscription
  extends Promise<AsyncIterator<AggregateExceptionRejection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleCategoryConfigSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleCategoryConfigSubscriptionPayloadPromise
  extends Promise<ScheduleCategoryConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleCategoryConfigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleCategoryConfigPreviousValuesPromise>() => T;
}

export interface ScheduleCategoryConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleCategoryConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleCategoryConfigPreviousValuesSubscription>() => T;
}

export interface AggregateExceptionElimination {
  count: Int;
}

export interface AggregateExceptionEliminationPromise
  extends Promise<AggregateExceptionElimination>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionEliminationSubscription
  extends Promise<AsyncIterator<AggregateExceptionElimination>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleCategoryConfigPreviousValues {
  id: ID_Output;
  category?: ScheduleCategory;
  backgroundColor: String;
  foregroundColor: String;
  description?: String;
}

export interface ScheduleCategoryConfigPreviousValuesPromise
  extends Promise<ScheduleCategoryConfigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleCategory>;
  backgroundColor: () => Promise<String>;
  foregroundColor: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ScheduleCategoryConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleCategory>>;
  backgroundColor: () => Promise<AsyncIterator<String>>;
  foregroundColor: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExceptionCancellation {
  count: Int;
}

export interface AggregateExceptionCancellationPromise
  extends Promise<AggregateExceptionCancellation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionCancellationSubscription
  extends Promise<AsyncIterator<AggregateExceptionCancellation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRole {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface UserRolePromise extends Promise<UserRole>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface UserRoleSubscription
  extends Promise<AsyncIterator<UserRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExceptionAuthorization {
  count: Int;
}

export interface AggregateExceptionAuthorizationPromise
  extends Promise<AggregateExceptionAuthorization>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionAuthorizationSubscription
  extends Promise<AsyncIterator<AggregateExceptionAuthorization>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleCreditSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleCreditSubscriptionPayloadPromise
  extends Promise<ScheduleCreditSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleCreditPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleCreditPreviousValuesPromise>() => T;
}

export interface ScheduleCreditSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleCreditSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleCreditSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleCreditPreviousValuesSubscription>() => T;
}

export interface ExceptionEdge {
  cursor: String;
}

export interface ExceptionEdgePromise
  extends Promise<ExceptionEdge>,
    Fragmentable {
  node: <T = ExceptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionEdgeSubscription
  extends Promise<AsyncIterator<ExceptionEdge>>,
    Fragmentable {
  node: <T = ExceptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCreditPreviousValues {
  id: ID_Output;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceDate: DateTimeOutput;
}

export interface ScheduleCreditPreviousValuesPromise
  extends Promise<ScheduleCreditPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
  sourceType: () => Promise<ScheduleCreditSourceEnum>;
  sourceDate: () => Promise<DateTimeOutput>;
}

export interface ScheduleCreditPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleCreditPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
  sourceType: () => Promise<AsyncIterator<ScheduleCreditSourceEnum>>;
  sourceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventSyncLogConnection {}

export interface EventSyncLogConnectionPromise
  extends Promise<EventSyncLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventSyncLogEdge>>() => T;
  aggregate: <T = AggregateEventSyncLogPromise>() => T;
}

export interface EventSyncLogConnectionSubscription
  extends Promise<AsyncIterator<EventSyncLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventSyncLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSyncLogSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  departments: <T = FragmentableArray<Department>>(
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  roles: <T = FragmentableArray<UserRole>>(
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  departments: <T = Promise<AsyncIterator<DepartmentSubscription>>>(
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  roles: <T = Promise<AsyncIterator<UserRoleSubscription>>>(
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EventEdge {
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleDebitSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleDebitSubscriptionPayloadPromise
  extends Promise<ScheduleDebitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleDebitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleDebitPreviousValuesPromise>() => T;
}

export interface ScheduleDebitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleDebitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleDebitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleDebitPreviousValuesSubscription>() => T;
}

export interface UserRoleConnection {}

export interface UserRoleConnectionPromise
  extends Promise<UserRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRoleEdge>>() => T;
  aggregate: <T = AggregateUserRolePromise>() => T;
}

export interface UserRoleConnectionSubscription
  extends Promise<AsyncIterator<UserRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserRoleSubscription>() => T;
}

export interface ScheduleDebitPreviousValues {
  id: ID_Output;
  category: ScheduleOfflineCategory;
  date: DateTimeOutput;
}

export interface ScheduleDebitPreviousValuesPromise
  extends Promise<ScheduleDebitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
  date: () => Promise<DateTimeOutput>;
}

export interface ScheduleDebitPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleDebitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShiftEdge {
  cursor: String;
}

export interface ShiftEdgePromise extends Promise<ShiftEdge>, Fragmentable {
  node: <T = ShiftPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShiftEdgeSubscription
  extends Promise<AsyncIterator<ShiftEdge>>,
    Fragmentable {
  node: <T = ShiftSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleOfflineElement {
  id: ID_Output;
  category: ScheduleOfflineCategory;
}

export interface ScheduleOfflineElementPromise
  extends Promise<ScheduleOfflineElement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
}

export interface ScheduleOfflineElementSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
}

export interface ScheduleDebitEdge {
  cursor: String;
}

export interface ScheduleDebitEdgePromise
  extends Promise<ScheduleDebitEdge>,
    Fragmentable {
  node: <T = ScheduleDebitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleDebitEdgeSubscription
  extends Promise<AsyncIterator<ScheduleDebitEdge>>,
    Fragmentable {
  node: <T = ScheduleDebitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleOfflineElementSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleOfflineElementSubscriptionPayloadPromise
  extends Promise<ScheduleOfflineElementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleOfflineElementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleOfflineElementPreviousValuesPromise>() => T;
}

export interface ScheduleOfflineElementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleOfflineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleOfflineElementPreviousValuesSubscription>() => T;
}

export interface UserRoleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserRoleSubscriptionPayloadPromise
  extends Promise<UserRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRolePreviousValuesPromise>() => T;
}

export interface UserRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRolePreviousValuesSubscription>() => T;
}

export interface ScheduleOfflineElementPreviousValues {
  id: ID_Output;
  category: ScheduleOfflineCategory;
}

export interface ScheduleOfflineElementPreviousValuesPromise
  extends Promise<ScheduleOfflineElementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
}

export interface ScheduleOfflineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
}

export interface HolidayConnection {}

export interface HolidayConnectionPromise
  extends Promise<HolidayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HolidayEdge>>() => T;
  aggregate: <T = AggregateHolidayPromise>() => T;
}

export interface HolidayConnectionSubscription
  extends Promise<AsyncIterator<HolidayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HolidayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHolidaySubscription>() => T;
}

export interface ScheduleRestlineElement {
  id: ID_Output;
  category: ScheduleRestlineCategory;
  duration: Int;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleRestlineElementPromise
  extends Promise<ScheduleRestlineElement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleRestlineCategory>;
  duration: () => Promise<Int>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleRestlineElementSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleRestlineCategory>>;
  duration: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExceptionSlotEdge {
  cursor: String;
}

export interface ExceptionSlotEdgePromise
  extends Promise<ExceptionSlotEdge>,
    Fragmentable {
  node: <T = ExceptionSlotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionSlotEdgeSubscription
  extends Promise<AsyncIterator<ExceptionSlotEdge>>,
    Fragmentable {
  node: <T = ExceptionSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleRestlineElementSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleRestlineElementSubscriptionPayloadPromise
  extends Promise<ScheduleRestlineElementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleRestlineElementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleRestlineElementPreviousValuesPromise>() => T;
}

export interface ScheduleRestlineElementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleRestlineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ScheduleRestlineElementPreviousValuesSubscription
  >() => T;
}

export interface ExceptionEliminationConnection {}

export interface ExceptionEliminationConnectionPromise
  extends Promise<ExceptionEliminationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExceptionEliminationEdge>>() => T;
  aggregate: <T = AggregateExceptionEliminationPromise>() => T;
}

export interface ExceptionEliminationConnectionSubscription
  extends Promise<AsyncIterator<ExceptionEliminationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExceptionEliminationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExceptionEliminationSubscription>() => T;
}

export interface ScheduleRestlineElementPreviousValues {
  id: ID_Output;
  category: ScheduleRestlineCategory;
  duration: Int;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleRestlineElementPreviousValuesPromise
  extends Promise<ScheduleRestlineElementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleRestlineCategory>;
  duration: () => Promise<Int>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleRestlineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleRestlineCategory>>;
  duration: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExceptionAuthorizationConnection {}

export interface ExceptionAuthorizationConnectionPromise
  extends Promise<ExceptionAuthorizationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExceptionAuthorizationEdge>>() => T;
  aggregate: <T = AggregateExceptionAuthorizationPromise>() => T;
}

export interface ExceptionAuthorizationConnectionSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExceptionAuthorizationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExceptionAuthorizationSubscription>() => T;
}

export interface ScheduleTimelineElement {
  id: ID_Output;
  category: ScheduleTimelineCategory;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleTimelineElementPromise
  extends Promise<ScheduleTimelineElement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleTimelineCategory>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleTimelineElementSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleTimelineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export interface EventSyncLog {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  from: DateTimeOutput;
  to: DateTimeOutput;
}

export interface EventSyncLogPromise
  extends Promise<EventSyncLog>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  from: () => Promise<DateTimeOutput>;
  to: () => Promise<DateTimeOutput>;
}

export interface EventSyncLogSubscription
  extends Promise<AsyncIterator<EventSyncLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  from: () => Promise<AsyncIterator<DateTimeOutput>>;
  to: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ScheduleTimelineElementSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleTimelineElementSubscriptionPayloadPromise
  extends Promise<ScheduleTimelineElementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleTimelineElementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleTimelineElementPreviousValuesPromise>() => T;
}

export interface ScheduleTimelineElementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleTimelineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ScheduleTimelineElementPreviousValuesSubscription
  >() => T;
}

export interface AggregateShiftSlot {
  count: Int;
}

export interface AggregateShiftSlotPromise
  extends Promise<AggregateShiftSlot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShiftSlotSubscription
  extends Promise<AsyncIterator<AggregateShiftSlot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleTimelineElementPreviousValues {
  id: ID_Output;
  category: ScheduleTimelineCategory;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleTimelineElementPreviousValuesPromise
  extends Promise<ScheduleTimelineElementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleTimelineCategory>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleTimelineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleTimelineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export interface ScheduleCreditConnection {}

export interface ScheduleCreditConnectionPromise
  extends Promise<ScheduleCreditConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleCreditEdge>>() => T;
  aggregate: <T = AggregateScheduleCreditPromise>() => T;
}

export interface ScheduleCreditConnectionSubscription
  extends Promise<AsyncIterator<ScheduleCreditConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleCreditEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleCreditSubscription>() => T;
}

export interface Schedule {
  id: ID_Output;
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  baseTime: Int;
  innerBound?: Int;
  outerBound?: Int;
}

export interface SchedulePromise extends Promise<Schedule>, Fragmentable {
  id: () => Promise<ID_Output>;
  isPreset: () => Promise<Boolean>;
  systemScheduleIdentifier: () => Promise<SystemScheduleIdentifierEnum>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  baseTime: () => Promise<Int>;
  innerBound: () => Promise<Int>;
  outerBound: () => Promise<Int>;
  timeline: <T = FragmentableArray<ScheduleTimelineElement>>(
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  restline: <T = FragmentableArray<ScheduleRestlineElement>>(
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  offline1: <T = ScheduleOfflineElementPromise>() => T;
  offline2: <T = ScheduleOfflineElementPromise>() => T;
}

export interface ScheduleSubscription
  extends Promise<AsyncIterator<Schedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPreset: () => Promise<AsyncIterator<Boolean>>;
  systemScheduleIdentifier: () => Promise<
    AsyncIterator<SystemScheduleIdentifierEnum>
  >;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  baseTime: () => Promise<AsyncIterator<Int>>;
  innerBound: () => Promise<AsyncIterator<Int>>;
  outerBound: () => Promise<AsyncIterator<Int>>;
  timeline: <T = Promise<AsyncIterator<ScheduleTimelineElementSubscription>>>(
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  restline: <T = Promise<AsyncIterator<ScheduleRestlineElementSubscription>>>(
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  offline1: <T = ScheduleOfflineElementSubscription>() => T;
  offline2: <T = ScheduleOfflineElementSubscription>() => T;
}

export interface FieldOptionLabelConnection {}

export interface FieldOptionLabelConnectionPromise
  extends Promise<FieldOptionLabelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldOptionLabelEdge>>() => T;
  aggregate: <T = AggregateFieldOptionLabelPromise>() => T;
}

export interface FieldOptionLabelConnectionSubscription
  extends Promise<AsyncIterator<FieldOptionLabelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldOptionLabelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldOptionLabelSubscription>() => T;
}

export interface ShiftSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ShiftSubscriptionPayloadPromise
  extends Promise<ShiftSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShiftPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShiftPreviousValuesPromise>() => T;
}

export interface ShiftSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShiftSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShiftSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShiftPreviousValuesSubscription>() => T;
}

export interface ExceptionCancellationConnection {}

export interface ExceptionCancellationConnectionPromise
  extends Promise<ExceptionCancellationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExceptionCancellationEdge>>() => T;
  aggregate: <T = AggregateExceptionCancellationPromise>() => T;
}

export interface ExceptionCancellationConnectionSubscription
  extends Promise<AsyncIterator<ExceptionCancellationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExceptionCancellationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExceptionCancellationSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ShiftSlotPreviousValues {
  id: ID_Output;
  index: Int;
}

export interface ShiftSlotPreviousValuesPromise
  extends Promise<ShiftSlotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
}

export interface ShiftSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<ShiftSlotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
}

export interface ShiftSlotSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ShiftSlotSubscriptionPayloadPromise
  extends Promise<ShiftSlotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShiftSlotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShiftSlotPreviousValuesPromise>() => T;
}

export interface ShiftSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShiftSlotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShiftSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShiftSlotPreviousValuesSubscription>() => T;
}

export interface ShiftSlot {
  id: ID_Output;
  index: Int;
}

export interface ShiftSlotPromise extends Promise<ShiftSlot>, Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  schedule: <T = SchedulePromise>() => T;
}

export interface ShiftSlotSubscription
  extends Promise<AsyncIterator<ShiftSlot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
  schedule: <T = ScheduleSubscription>() => T;
}

export interface ShiftPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface ShiftPreviousValuesPromise
  extends Promise<ShiftPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface ShiftPreviousValuesSubscription
  extends Promise<AsyncIterator<ShiftPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ScheduleTimelineElementConnection {}

export interface ScheduleTimelineElementConnectionPromise
  extends Promise<ScheduleTimelineElementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleTimelineElementEdge>>() => T;
  aggregate: <T = AggregateScheduleTimelineElementPromise>() => T;
}

export interface ScheduleTimelineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleTimelineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleTimelineElementSubscription>() => T;
}

export interface AggregateEventSyncLog {
  count: Int;
}

export interface AggregateEventSyncLogPromise
  extends Promise<AggregateEventSyncLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSyncLogSubscription
  extends Promise<AsyncIterator<AggregateEventSyncLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionRejectionConnection {}

export interface ExceptionRejectionConnectionPromise
  extends Promise<ExceptionRejectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExceptionRejectionEdge>>() => T;
  aggregate: <T = AggregateExceptionRejectionPromise>() => T;
}

export interface ExceptionRejectionConnectionSubscription
  extends Promise<AsyncIterator<ExceptionRejectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExceptionRejectionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExceptionRejectionSubscription>() => T;
}

export interface ScheduleConnection {}

export interface ScheduleConnectionPromise
  extends Promise<ScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleEdge>>() => T;
  aggregate: <T = AggregateSchedulePromise>() => T;
}

export interface ScheduleConnectionSubscription
  extends Promise<AsyncIterator<ScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleSubscription>() => T;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "AttendanceCategory",
    embedded: false
  },
  {
    name: "AttendanceCycle",
    embedded: false
  },
  {
    name: "ContractCancelMotiveEnum",
    embedded: false
  },
  {
    name: "ContractModalityEnum",
    embedded: false
  },
  {
    name: "ContractTypeEnum",
    embedded: false
  },
  {
    name: "ContractWorkClassEnum",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "DirectCredit",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "EmployeeAFPEnum",
    embedded: false
  },
  {
    name: "EmployeeCajaDeSaludEnum",
    embedded: false
  },
  {
    name: "EmployeeDocumentTypeEnum",
    embedded: false
  },
  {
    name: "EmployeeSexEnum",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "EventSyncLog",
    embedded: false
  },
  {
    name: "Exception",
    embedded: false
  },
  {
    name: "ExceptionAuthorization",
    embedded: false
  },
  {
    name: "ExceptionCancellation",
    embedded: false
  },
  {
    name: "ExceptionElimination",
    embedded: false
  },
  {
    name: "ExceptionRejection",
    embedded: false
  },
  {
    name: "ExceptionSlot",
    embedded: false
  },
  {
    name: "ExceptionTypeEnum",
    embedded: false
  },
  {
    name: "FieldOptionLabel",
    embedded: false
  },
  {
    name: "Holiday",
    embedded: false
  },
  {
    name: "Schedule",
    embedded: false
  },
  {
    name: "ScheduleCategory",
    embedded: false
  },
  {
    name: "ScheduleCategoryConfig",
    embedded: false
  },
  {
    name: "ScheduleCredit",
    embedded: false
  },
  {
    name: "ScheduleCreditSourceEnum",
    embedded: false
  },
  {
    name: "ScheduleDebit",
    embedded: false
  },
  {
    name: "ScheduleOfflineCategory",
    embedded: false
  },
  {
    name: "ScheduleOfflineElement",
    embedded: false
  },
  {
    name: "ScheduleRestlineCategory",
    embedded: false
  },
  {
    name: "ScheduleRestlineElement",
    embedded: false
  },
  {
    name: "ScheduleTimelineCategory",
    embedded: false
  },
  {
    name: "ScheduleTimelineElement",
    embedded: false
  },
  {
    name: "Shift",
    embedded: false
  },
  {
    name: "ShiftSlot",
    embedded: false
  },
  {
    name: "SystemScheduleIdentifierEnum",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "UserRoleEnum",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;

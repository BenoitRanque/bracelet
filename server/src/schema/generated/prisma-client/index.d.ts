// Code generated by Prisma (prisma@1.22.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  activation: (where?: ActivationWhereInput) => Promise<boolean>;
  bracelet: (where?: BraceletWhereInput) => Promise<boolean>;
  check: (where?: CheckWhereInput) => Promise<boolean>;
  checkpoint: (where?: CheckpointWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activation: (where: ActivationWhereUniqueInput) => ActivationPromise;
  activations: (
    args?: {
      where?: ActivationWhereInput;
      orderBy?: ActivationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Activation>;
  activationsConnection: (
    args?: {
      where?: ActivationWhereInput;
      orderBy?: ActivationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ActivationConnectionPromise;
  bracelet: (where: BraceletWhereUniqueInput) => BraceletPromise;
  bracelets: (
    args?: {
      where?: BraceletWhereInput;
      orderBy?: BraceletOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Bracelet>;
  braceletsConnection: (
    args?: {
      where?: BraceletWhereInput;
      orderBy?: BraceletOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BraceletConnectionPromise;
  check: (where: CheckWhereUniqueInput) => CheckPromise;
  checks: (
    args?: {
      where?: CheckWhereInput;
      orderBy?: CheckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Check>;
  checksConnection: (
    args?: {
      where?: CheckWhereInput;
      orderBy?: CheckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CheckConnectionPromise;
  checkpoint: (where: CheckpointWhereUniqueInput) => CheckpointPromise;
  checkpoints: (
    args?: {
      where?: CheckpointWhereInput;
      orderBy?: CheckpointOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Checkpoint>;
  checkpointsConnection: (
    args?: {
      where?: CheckpointWhereInput;
      orderBy?: CheckpointOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CheckpointConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupPromise;
  groups: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Group>;
  groupsConnection: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GroupConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivation: (data: ActivationCreateInput) => ActivationPromise;
  updateActivation: (
    args: { data: ActivationUpdateInput; where: ActivationWhereUniqueInput }
  ) => ActivationPromise;
  upsertActivation: (
    args: {
      where: ActivationWhereUniqueInput;
      create: ActivationCreateInput;
      update: ActivationUpdateInput;
    }
  ) => ActivationPromise;
  deleteActivation: (where: ActivationWhereUniqueInput) => ActivationPromise;
  deleteManyActivations: (where?: ActivationWhereInput) => BatchPayloadPromise;
  createBracelet: (data: BraceletCreateInput) => BraceletPromise;
  updateBracelet: (
    args: { data: BraceletUpdateInput; where: BraceletWhereUniqueInput }
  ) => BraceletPromise;
  updateManyBracelets: (
    args: { data: BraceletUpdateManyMutationInput; where?: BraceletWhereInput }
  ) => BatchPayloadPromise;
  upsertBracelet: (
    args: {
      where: BraceletWhereUniqueInput;
      create: BraceletCreateInput;
      update: BraceletUpdateInput;
    }
  ) => BraceletPromise;
  deleteBracelet: (where: BraceletWhereUniqueInput) => BraceletPromise;
  deleteManyBracelets: (where?: BraceletWhereInput) => BatchPayloadPromise;
  createCheck: (data: CheckCreateInput) => CheckPromise;
  updateCheck: (
    args: { data: CheckUpdateInput; where: CheckWhereUniqueInput }
  ) => CheckPromise;
  updateManyChecks: (
    args: { data: CheckUpdateManyMutationInput; where?: CheckWhereInput }
  ) => BatchPayloadPromise;
  upsertCheck: (
    args: {
      where: CheckWhereUniqueInput;
      create: CheckCreateInput;
      update: CheckUpdateInput;
    }
  ) => CheckPromise;
  deleteCheck: (where: CheckWhereUniqueInput) => CheckPromise;
  deleteManyChecks: (where?: CheckWhereInput) => BatchPayloadPromise;
  createCheckpoint: (data: CheckpointCreateInput) => CheckpointPromise;
  updateCheckpoint: (
    args: { data: CheckpointUpdateInput; where: CheckpointWhereUniqueInput }
  ) => CheckpointPromise;
  updateManyCheckpoints: (
    args: {
      data: CheckpointUpdateManyMutationInput;
      where?: CheckpointWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCheckpoint: (
    args: {
      where: CheckpointWhereUniqueInput;
      create: CheckpointCreateInput;
      update: CheckpointUpdateInput;
    }
  ) => CheckpointPromise;
  deleteCheckpoint: (where: CheckpointWhereUniqueInput) => CheckpointPromise;
  deleteManyCheckpoints: (where?: CheckpointWhereInput) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (
    args: { data: GroupUpdateInput; where: GroupWhereUniqueInput }
  ) => GroupPromise;
  updateManyGroups: (
    args: { data: GroupUpdateManyMutationInput; where?: GroupWhereInput }
  ) => BatchPayloadPromise;
  upsertGroup: (
    args: {
      where: GroupWhereUniqueInput;
      create: GroupCreateInput;
      update: GroupUpdateInput;
    }
  ) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activation: (
    where?: ActivationSubscriptionWhereInput
  ) => ActivationSubscriptionPayloadSubscription;
  bracelet: (
    where?: BraceletSubscriptionWhereInput
  ) => BraceletSubscriptionPayloadSubscription;
  check: (
    where?: CheckSubscriptionWhereInput
  ) => CheckSubscriptionPayloadSubscription;
  checkpoint: (
    where?: CheckpointSubscriptionWhereInput
  ) => CheckpointSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "code_ASC"
  | "code_DESC";

export type BraceletOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "code_ASC"
  | "code_DESC";

export type CheckOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "timestamp_ASC"
  | "timestamp_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "checklimit_ASC"
  | "checklimit_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActivationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CheckpointOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CheckpointUpdateOneRequiredWithoutChecksInput {
  create?: CheckpointCreateWithoutChecksInput;
  update?: CheckpointUpdateWithoutChecksDataInput;
  upsert?: CheckpointUpsertWithoutChecksInput;
  connect?: CheckpointWhereUniqueInput;
}

export type ActivationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ActivationUpdateManyWithoutProductsInput {
  create?:
    | ActivationCreateWithoutProductsInput[]
    | ActivationCreateWithoutProductsInput;
  delete?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
  connect?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
  disconnect?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
  update?:
    | ActivationUpdateWithWhereUniqueWithoutProductsInput[]
    | ActivationUpdateWithWhereUniqueWithoutProductsInput;
  upsert?:
    | ActivationUpsertWithWhereUniqueWithoutProductsInput[]
    | ActivationUpsertWithWhereUniqueWithoutProductsInput;
  deleteMany?: ActivationScalarWhereInput[] | ActivationScalarWhereInput;
}

export interface CheckpointWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  checks_every?: CheckWhereInput;
  checks_some?: CheckWhereInput;
  checks_none?: CheckWhereInput;
  AND?: CheckpointWhereInput[] | CheckpointWhereInput;
  OR?: CheckpointWhereInput[] | CheckpointWhereInput;
  NOT?: CheckpointWhereInput[] | CheckpointWhereInput;
}

export interface ActivationUpdateWithWhereUniqueWithoutProductsInput {
  where: ActivationWhereUniqueInput;
  data: ActivationUpdateWithoutProductsDataInput;
}

export interface BraceletWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  group?: GroupWhereInput;
  checks_every?: CheckWhereInput;
  checks_some?: CheckWhereInput;
  checks_none?: CheckWhereInput;
  AND?: BraceletWhereInput[] | BraceletWhereInput;
  OR?: BraceletWhereInput[] | BraceletWhereInput;
  NOT?: BraceletWhereInput[] | BraceletWhereInput;
}

export interface ActivationUpdateWithoutProductsDataInput {
  owner?: UserUpdateOneRequiredWithoutActivatedGroupsInput;
  groups?: GroupUpdateManyWithoutActivationInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  activations_every?: ActivationWhereInput;
  activations_some?: ActivationWhereInput;
  activations_none?: ActivationWhereInput;
  checkpoint?: CheckpointWhereInput;
  checklimit?: Int;
  checklimit_not?: Int;
  checklimit_in?: Int[] | Int;
  checklimit_not_in?: Int[] | Int;
  checklimit_lt?: Int;
  checklimit_lte?: Int;
  checklimit_gt?: Int;
  checklimit_gte?: Int;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface GroupUpdateManyWithoutActivationInput {
  create?:
    | GroupCreateWithoutActivationInput[]
    | GroupCreateWithoutActivationInput;
  delete?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  disconnect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  update?:
    | GroupUpdateWithWhereUniqueWithoutActivationInput[]
    | GroupUpdateWithWhereUniqueWithoutActivationInput;
  upsert?:
    | GroupUpsertWithWhereUniqueWithoutActivationInput[]
    | GroupUpsertWithWhereUniqueWithoutActivationInput;
  deleteMany?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  updateMany?:
    | GroupUpdateManyWithWhereNestedInput[]
    | GroupUpdateManyWithWhereNestedInput;
}

export interface ActivationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  owner?: UserWhereInput;
  groups_every?: GroupWhereInput;
  groups_some?: GroupWhereInput;
  groups_none?: GroupWhereInput;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: ActivationWhereInput[] | ActivationWhereInput;
  OR?: ActivationWhereInput[] | ActivationWhereInput;
  NOT?: ActivationWhereInput[] | ActivationWhereInput;
}

export interface GroupUpdateWithWhereUniqueWithoutActivationInput {
  where: GroupWhereUniqueInput;
  data: GroupUpdateWithoutActivationDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  createdGroups_every?: GroupWhereInput;
  createdGroups_some?: GroupWhereInput;
  createdGroups_none?: GroupWhereInput;
  activatedGroups_every?: ActivationWhereInput;
  activatedGroups_some?: ActivationWhereInput;
  activatedGroups_none?: ActivationWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ActivationCreateOneWithoutGroupsInput {
  create?: ActivationCreateWithoutGroupsInput;
  connect?: ActivationWhereUniqueInput;
}

export interface CheckpointUpsertWithoutChecksInput {
  update: CheckpointUpdateWithoutChecksDataInput;
  create: CheckpointCreateWithoutChecksInput;
}

export interface ActivationCreateWithoutGroupsInput {
  owner: UserCreateOneWithoutActivatedGroupsInput;
  products?: ProductCreateManyWithoutActivationsInput;
}

export interface GroupUpdateWithoutActivationDataInput {
  owner?: UserUpdateOneRequiredWithoutCreatedGroupsInput;
  code?: String;
  bracelets?: BraceletUpdateManyWithoutGroupInput;
}

export interface ActivationUpdateInput {
  owner?: UserUpdateOneRequiredWithoutActivatedGroupsInput;
  groups?: GroupUpdateManyWithoutActivationInput;
  products?: ProductUpdateManyWithoutActivationsInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutActivatedGroupsInput {
  create?: UserCreateWithoutActivatedGroupsInput;
  update?: UserUpdateWithoutActivatedGroupsDataInput;
  upsert?: UserUpsertWithoutActivatedGroupsInput;
  connect?: UserWhereUniqueInput;
}

export interface CheckpointSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CheckpointWhereInput;
  AND?: CheckpointSubscriptionWhereInput[] | CheckpointSubscriptionWhereInput;
  OR?: CheckpointSubscriptionWhereInput[] | CheckpointSubscriptionWhereInput;
  NOT?: CheckpointSubscriptionWhereInput[] | CheckpointSubscriptionWhereInput;
}

export interface UserUpdateWithoutActivatedGroupsDataInput {
  username?: String;
  password?: String;
  createdGroups?: GroupUpdateManyWithoutOwnerInput;
}

export interface BraceletSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BraceletWhereInput;
  AND?: BraceletSubscriptionWhereInput[] | BraceletSubscriptionWhereInput;
  OR?: BraceletSubscriptionWhereInput[] | BraceletSubscriptionWhereInput;
  NOT?: BraceletSubscriptionWhereInput[] | BraceletSubscriptionWhereInput;
}

export interface GroupUpdateManyWithoutOwnerInput {
  create?: GroupCreateWithoutOwnerInput[] | GroupCreateWithoutOwnerInput;
  delete?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  disconnect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  update?:
    | GroupUpdateWithWhereUniqueWithoutOwnerInput[]
    | GroupUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | GroupUpsertWithWhereUniqueWithoutOwnerInput[]
    | GroupUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  updateMany?:
    | GroupUpdateManyWithWhereNestedInput[]
    | GroupUpdateManyWithWhereNestedInput;
}

export type BraceletWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface GroupUpdateWithWhereUniqueWithoutOwnerInput {
  where: GroupWhereUniqueInput;
  data: GroupUpdateWithoutOwnerDataInput;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  createdGroups?: GroupUpdateManyWithoutOwnerInput;
  activatedGroups?: ActivationUpdateManyWithoutOwnerInput;
}

export interface GroupUpdateWithoutOwnerDataInput {
  code?: String;
  bracelets?: BraceletUpdateManyWithoutGroupInput;
  activation?: ActivationUpdateOneWithoutGroupsInput;
}

export type CheckWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BraceletUpdateManyWithoutGroupInput {
  create?: BraceletCreateWithoutGroupInput[] | BraceletCreateWithoutGroupInput;
  delete?: BraceletWhereUniqueInput[] | BraceletWhereUniqueInput;
  connect?: BraceletWhereUniqueInput[] | BraceletWhereUniqueInput;
  disconnect?: BraceletWhereUniqueInput[] | BraceletWhereUniqueInput;
  update?:
    | BraceletUpdateWithWhereUniqueWithoutGroupInput[]
    | BraceletUpdateWithWhereUniqueWithoutGroupInput;
  upsert?:
    | BraceletUpsertWithWhereUniqueWithoutGroupInput[]
    | BraceletUpsertWithWhereUniqueWithoutGroupInput;
  deleteMany?: BraceletScalarWhereInput[] | BraceletScalarWhereInput;
  updateMany?:
    | BraceletUpdateManyWithWhereNestedInput[]
    | BraceletUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateInput {
  name?: String;
  description?: String;
  activations?: ActivationUpdateManyWithoutProductsInput;
  checkpoint?: CheckpointUpdateOneRequiredWithoutProductsInput;
  checklimit?: Int;
}

export interface BraceletUpdateWithWhereUniqueWithoutGroupInput {
  where: BraceletWhereUniqueInput;
  data: BraceletUpdateWithoutGroupDataInput;
}

export type CheckpointWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface BraceletUpdateWithoutGroupDataInput {
  code?: String;
  checks?: CheckUpdateManyWithoutBraceletInput;
}

export interface GroupUpdateInput {
  owner?: UserUpdateOneRequiredWithoutCreatedGroupsInput;
  code?: String;
  bracelets?: BraceletUpdateManyWithoutGroupInput;
  activation?: ActivationUpdateOneWithoutGroupsInput;
}

export interface CheckUpdateManyWithoutBraceletInput {
  create?: CheckCreateWithoutBraceletInput[] | CheckCreateWithoutBraceletInput;
  delete?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
  connect?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
  disconnect?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
  update?:
    | CheckUpdateWithWhereUniqueWithoutBraceletInput[]
    | CheckUpdateWithWhereUniqueWithoutBraceletInput;
  upsert?:
    | CheckUpsertWithWhereUniqueWithoutBraceletInput[]
    | CheckUpsertWithWhereUniqueWithoutBraceletInput;
  deleteMany?: CheckScalarWhereInput[] | CheckScalarWhereInput;
  updateMany?:
    | CheckUpdateManyWithWhereNestedInput[]
    | CheckUpdateManyWithWhereNestedInput;
}

export interface CheckpointUpdateManyMutationInput {
  name?: String;
}

export interface CheckUpdateWithWhereUniqueWithoutBraceletInput {
  where: CheckWhereUniqueInput;
  data: CheckUpdateWithoutBraceletDataInput;
}

export interface CheckpointUpdateInput {
  name?: String;
  products?: ProductUpdateManyWithoutCheckpointInput;
  checks?: CheckUpdateManyWithoutCheckpointInput;
}

export interface CheckUpdateWithoutBraceletDataInput {
  timestamp?: DateTimeInput;
  checkpoint?: CheckpointUpdateOneRequiredWithoutChecksInput;
}

export interface CheckUpdateManyMutationInput {
  timestamp?: DateTimeInput;
}

export interface BraceletUpdateManyDataInput {
  code?: String;
}

export interface CheckUpdateInput {
  timestamp?: DateTimeInput;
  bracelet?: BraceletUpdateOneRequiredWithoutChecksInput;
  checkpoint?: CheckpointUpdateOneRequiredWithoutChecksInput;
}

export interface CheckpointUpdateWithoutChecksDataInput {
  name?: String;
  products?: ProductUpdateManyWithoutCheckpointInput;
}

export interface BraceletUpdateManyMutationInput {
  code?: String;
}

export interface ProductUpdateManyWithoutCheckpointInput {
  create?:
    | ProductCreateWithoutCheckpointInput[]
    | ProductCreateWithoutCheckpointInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutCheckpointInput[]
    | ProductUpdateWithWhereUniqueWithoutCheckpointInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutCheckpointInput[]
    | ProductUpsertWithWhereUniqueWithoutCheckpointInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface BraceletUpdateInput {
  code?: String;
  group?: GroupUpdateOneRequiredWithoutBraceletsInput;
  checks?: CheckUpdateManyWithoutBraceletInput;
}

export interface ProductUpdateWithWhereUniqueWithoutCheckpointInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCheckpointDataInput;
}

export interface UserUpsertWithoutActivatedGroupsInput {
  update: UserUpdateWithoutActivatedGroupsDataInput;
  create: UserCreateWithoutActivatedGroupsInput;
}

export interface ProductUpdateWithoutCheckpointDataInput {
  name?: String;
  description?: String;
  activations?: ActivationUpdateManyWithoutProductsInput;
  checklimit?: Int;
}

export interface UserCreateOneWithoutActivatedGroupsInput {
  create?: UserCreateWithoutActivatedGroupsInput;
  connect?: UserWhereUniqueInput;
}

export interface CheckWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  timestamp?: DateTimeInput;
  timestamp_not?: DateTimeInput;
  timestamp_in?: DateTimeInput[] | DateTimeInput;
  timestamp_not_in?: DateTimeInput[] | DateTimeInput;
  timestamp_lt?: DateTimeInput;
  timestamp_lte?: DateTimeInput;
  timestamp_gt?: DateTimeInput;
  timestamp_gte?: DateTimeInput;
  bracelet?: BraceletWhereInput;
  checkpoint?: CheckpointWhereInput;
  AND?: CheckWhereInput[] | CheckWhereInput;
  OR?: CheckWhereInput[] | CheckWhereInput;
  NOT?: CheckWhereInput[] | CheckWhereInput;
}

export interface GroupCreateManyWithoutOwnerInput {
  create?: GroupCreateWithoutOwnerInput[] | GroupCreateWithoutOwnerInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
}

export interface BraceletUpdateManyWithWhereNestedInput {
  where: BraceletScalarWhereInput;
  data: BraceletUpdateManyDataInput;
}

export interface BraceletCreateManyWithoutGroupInput {
  create?: BraceletCreateWithoutGroupInput[] | BraceletCreateWithoutGroupInput;
  connect?: BraceletWhereUniqueInput[] | BraceletWhereUniqueInput;
}

export interface BraceletScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  AND?: BraceletScalarWhereInput[] | BraceletScalarWhereInput;
  OR?: BraceletScalarWhereInput[] | BraceletScalarWhereInput;
  NOT?: BraceletScalarWhereInput[] | BraceletScalarWhereInput;
}

export interface CheckCreateManyWithoutBraceletInput {
  create?: CheckCreateWithoutBraceletInput[] | CheckCreateWithoutBraceletInput;
  connect?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
}

export interface BraceletUpsertWithWhereUniqueWithoutGroupInput {
  where: BraceletWhereUniqueInput;
  update: BraceletUpdateWithoutGroupDataInput;
  create: BraceletCreateWithoutGroupInput;
}

export interface CheckpointCreateOneWithoutChecksInput {
  create?: CheckpointCreateWithoutChecksInput;
  connect?: CheckpointWhereUniqueInput;
}

export interface CheckUpsertWithWhereUniqueWithoutBraceletInput {
  where: CheckWhereUniqueInput;
  update: CheckUpdateWithoutBraceletDataInput;
  create: CheckCreateWithoutBraceletInput;
}

export interface ProductCreateManyWithoutCheckpointInput {
  create?:
    | ProductCreateWithoutCheckpointInput[]
    | ProductCreateWithoutCheckpointInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface GroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  owner?: UserWhereInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  bracelets_every?: BraceletWhereInput;
  bracelets_some?: BraceletWhereInput;
  bracelets_none?: BraceletWhereInput;
  activation?: ActivationWhereInput;
  AND?: GroupWhereInput[] | GroupWhereInput;
  OR?: GroupWhereInput[] | GroupWhereInput;
  NOT?: GroupWhereInput[] | GroupWhereInput;
}

export interface ActivationCreateManyWithoutProductsInput {
  create?:
    | ActivationCreateWithoutProductsInput[]
    | ActivationCreateWithoutProductsInput;
  connect?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutCreatedGroupsInput {
  create?: UserCreateWithoutCreatedGroupsInput;
  update?: UserUpdateWithoutCreatedGroupsDataInput;
  upsert?: UserUpsertWithoutCreatedGroupsInput;
  connect?: UserWhereUniqueInput;
}

export interface GroupCreateManyWithoutActivationInput {
  create?:
    | GroupCreateWithoutActivationInput[]
    | GroupCreateWithoutActivationInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
}

export interface UserUpdateWithoutCreatedGroupsDataInput {
  username?: String;
  password?: String;
  activatedGroups?: ActivationUpdateManyWithoutOwnerInput;
}

export interface UserCreateOneWithoutCreatedGroupsInput {
  create?: UserCreateWithoutCreatedGroupsInput;
  connect?: UserWhereUniqueInput;
}

export interface ActivationUpdateManyWithoutOwnerInput {
  create?:
    | ActivationCreateWithoutOwnerInput[]
    | ActivationCreateWithoutOwnerInput;
  delete?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
  connect?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
  disconnect?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
  update?:
    | ActivationUpdateWithWhereUniqueWithoutOwnerInput[]
    | ActivationUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | ActivationUpsertWithWhereUniqueWithoutOwnerInput[]
    | ActivationUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: ActivationScalarWhereInput[] | ActivationScalarWhereInput;
}

export interface ActivationCreateManyWithoutOwnerInput {
  create?:
    | ActivationCreateWithoutOwnerInput[]
    | ActivationCreateWithoutOwnerInput;
  connect?: ActivationWhereUniqueInput[] | ActivationWhereUniqueInput;
}

export interface ActivationUpdateWithWhereUniqueWithoutOwnerInput {
  where: ActivationWhereUniqueInput;
  data: ActivationUpdateWithoutOwnerDataInput;
}

export interface ProductCreateManyWithoutActivationsInput {
  create?:
    | ProductCreateWithoutActivationsInput[]
    | ProductCreateWithoutActivationsInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ActivationUpdateWithoutOwnerDataInput {
  groups?: GroupUpdateManyWithoutActivationInput;
  products?: ProductUpdateManyWithoutActivationsInput;
}

export interface CheckpointCreateOneWithoutProductsInput {
  create?: CheckpointCreateWithoutProductsInput;
  connect?: CheckpointWhereUniqueInput;
}

export interface ProductUpdateManyWithoutActivationsInput {
  create?:
    | ProductCreateWithoutActivationsInput[]
    | ProductCreateWithoutActivationsInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutActivationsInput[]
    | ProductUpdateWithWhereUniqueWithoutActivationsInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutActivationsInput[]
    | ProductUpsertWithWhereUniqueWithoutActivationsInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface CheckCreateManyWithoutCheckpointInput {
  create?:
    | CheckCreateWithoutCheckpointInput[]
    | CheckCreateWithoutCheckpointInput;
  connect?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
}

export interface ProductUpdateWithWhereUniqueWithoutActivationsInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutActivationsDataInput;
}

export interface BraceletCreateOneWithoutChecksInput {
  create?: BraceletCreateWithoutChecksInput;
  connect?: BraceletWhereUniqueInput;
}

export interface ProductUpdateWithoutActivationsDataInput {
  name?: String;
  description?: String;
  checkpoint?: CheckpointUpdateOneRequiredWithoutProductsInput;
  checklimit?: Int;
}

export interface GroupCreateOneWithoutBraceletsInput {
  create?: GroupCreateWithoutBraceletsInput;
  connect?: GroupWhereUniqueInput;
}

export interface CheckpointUpdateOneRequiredWithoutProductsInput {
  create?: CheckpointCreateWithoutProductsInput;
  update?: CheckpointUpdateWithoutProductsDataInput;
  upsert?: CheckpointUpsertWithoutProductsInput;
  connect?: CheckpointWhereUniqueInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CheckpointUpdateWithoutProductsDataInput {
  name?: String;
  checks?: CheckUpdateManyWithoutCheckpointInput;
}

export interface CheckSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CheckWhereInput;
  AND?: CheckSubscriptionWhereInput[] | CheckSubscriptionWhereInput;
  OR?: CheckSubscriptionWhereInput[] | CheckSubscriptionWhereInput;
  NOT?: CheckSubscriptionWhereInput[] | CheckSubscriptionWhereInput;
}

export interface CheckUpdateManyWithoutCheckpointInput {
  create?:
    | CheckCreateWithoutCheckpointInput[]
    | CheckCreateWithoutCheckpointInput;
  delete?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
  connect?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
  disconnect?: CheckWhereUniqueInput[] | CheckWhereUniqueInput;
  update?:
    | CheckUpdateWithWhereUniqueWithoutCheckpointInput[]
    | CheckUpdateWithWhereUniqueWithoutCheckpointInput;
  upsert?:
    | CheckUpsertWithWhereUniqueWithoutCheckpointInput[]
    | CheckUpsertWithWhereUniqueWithoutCheckpointInput;
  deleteMany?: CheckScalarWhereInput[] | CheckScalarWhereInput;
  updateMany?:
    | CheckUpdateManyWithWhereNestedInput[]
    | CheckUpdateManyWithWhereNestedInput;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  password?: String;
}

export interface CheckUpdateWithWhereUniqueWithoutCheckpointInput {
  where: CheckWhereUniqueInput;
  data: CheckUpdateWithoutCheckpointDataInput;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
  description?: String;
  checklimit?: Int;
}

export interface CheckUpdateWithoutCheckpointDataInput {
  timestamp?: DateTimeInput;
  bracelet?: BraceletUpdateOneRequiredWithoutChecksInput;
}

export interface GroupUpdateManyMutationInput {
  code?: String;
}

export interface BraceletUpdateOneRequiredWithoutChecksInput {
  create?: BraceletCreateWithoutChecksInput;
  update?: BraceletUpdateWithoutChecksDataInput;
  upsert?: BraceletUpsertWithoutChecksInput;
  connect?: BraceletWhereUniqueInput;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface BraceletUpdateWithoutChecksDataInput {
  code?: String;
  group?: GroupUpdateOneRequiredWithoutBraceletsInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface GroupUpdateOneRequiredWithoutBraceletsInput {
  create?: GroupCreateWithoutBraceletsInput;
  update?: GroupUpdateWithoutBraceletsDataInput;
  upsert?: GroupUpsertWithoutBraceletsInput;
  connect?: GroupWhereUniqueInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface GroupUpdateWithoutBraceletsDataInput {
  owner?: UserUpdateOneRequiredWithoutCreatedGroupsInput;
  code?: String;
  activation?: ActivationUpdateOneWithoutGroupsInput;
}

export interface GroupUpsertWithWhereUniqueWithoutOwnerInput {
  where: GroupWhereUniqueInput;
  update: GroupUpdateWithoutOwnerDataInput;
  create: GroupCreateWithoutOwnerInput;
}

export interface ActivationUpdateOneWithoutGroupsInput {
  create?: ActivationCreateWithoutGroupsInput;
  update?: ActivationUpdateWithoutGroupsDataInput;
  upsert?: ActivationUpsertWithoutGroupsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ActivationWhereUniqueInput;
}

export interface UserCreateWithoutActivatedGroupsInput {
  username: String;
  password: String;
  createdGroups?: GroupCreateManyWithoutOwnerInput;
}

export interface ActivationUpdateWithoutGroupsDataInput {
  owner?: UserUpdateOneRequiredWithoutActivatedGroupsInput;
  products?: ProductUpdateManyWithoutActivationsInput;
}

export interface BraceletCreateWithoutGroupInput {
  code: String;
  checks?: CheckCreateManyWithoutBraceletInput;
}

export interface ActivationUpsertWithoutGroupsInput {
  update: ActivationUpdateWithoutGroupsDataInput;
  create: ActivationCreateWithoutGroupsInput;
}

export interface CheckpointCreateWithoutChecksInput {
  name: String;
  products?: ProductCreateManyWithoutCheckpointInput;
}

export interface GroupUpsertWithoutBraceletsInput {
  update: GroupUpdateWithoutBraceletsDataInput;
  create: GroupCreateWithoutBraceletsInput;
}

export interface ActivationCreateWithoutProductsInput {
  owner: UserCreateOneWithoutActivatedGroupsInput;
  groups?: GroupCreateManyWithoutActivationInput;
}

export interface BraceletUpsertWithoutChecksInput {
  update: BraceletUpdateWithoutChecksDataInput;
  create: BraceletCreateWithoutChecksInput;
}

export interface UserCreateWithoutCreatedGroupsInput {
  username: String;
  password: String;
  activatedGroups?: ActivationCreateManyWithoutOwnerInput;
}

export interface CheckUpsertWithWhereUniqueWithoutCheckpointInput {
  where: CheckWhereUniqueInput;
  update: CheckUpdateWithoutCheckpointDataInput;
  create: CheckCreateWithoutCheckpointInput;
}

export interface ProductCreateWithoutActivationsInput {
  name: String;
  description: String;
  checkpoint: CheckpointCreateOneWithoutProductsInput;
  checklimit?: Int;
}

export interface CheckScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  timestamp?: DateTimeInput;
  timestamp_not?: DateTimeInput;
  timestamp_in?: DateTimeInput[] | DateTimeInput;
  timestamp_not_in?: DateTimeInput[] | DateTimeInput;
  timestamp_lt?: DateTimeInput;
  timestamp_lte?: DateTimeInput;
  timestamp_gt?: DateTimeInput;
  timestamp_gte?: DateTimeInput;
  AND?: CheckScalarWhereInput[] | CheckScalarWhereInput;
  OR?: CheckScalarWhereInput[] | CheckScalarWhereInput;
  NOT?: CheckScalarWhereInput[] | CheckScalarWhereInput;
}

export interface CheckCreateWithoutCheckpointInput {
  timestamp: DateTimeInput;
  bracelet: BraceletCreateOneWithoutChecksInput;
}

export interface CheckUpdateManyWithWhereNestedInput {
  where: CheckScalarWhereInput;
  data: CheckUpdateManyDataInput;
}

export interface GroupCreateWithoutBraceletsInput {
  owner: UserCreateOneWithoutCreatedGroupsInput;
  code: String;
  activation?: ActivationCreateOneWithoutGroupsInput;
}

export interface CheckUpdateManyDataInput {
  timestamp?: DateTimeInput;
}

export interface ActivationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivationWhereInput;
  AND?: ActivationSubscriptionWhereInput[] | ActivationSubscriptionWhereInput;
  OR?: ActivationSubscriptionWhereInput[] | ActivationSubscriptionWhereInput;
  NOT?: ActivationSubscriptionWhereInput[] | ActivationSubscriptionWhereInput;
}

export interface CheckpointUpsertWithoutProductsInput {
  update: CheckpointUpdateWithoutProductsDataInput;
  create: CheckpointCreateWithoutProductsInput;
}

export interface ProductCreateInput {
  name: String;
  description: String;
  activations?: ActivationCreateManyWithoutProductsInput;
  checkpoint: CheckpointCreateOneWithoutProductsInput;
  checklimit?: Int;
}

export interface ProductUpsertWithWhereUniqueWithoutActivationsInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutActivationsDataInput;
  create: ProductCreateWithoutActivationsInput;
}

export interface CheckpointCreateInput {
  name: String;
  products?: ProductCreateManyWithoutCheckpointInput;
  checks?: CheckCreateManyWithoutCheckpointInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  checklimit?: Int;
  checklimit_not?: Int;
  checklimit_in?: Int[] | Int;
  checklimit_not_in?: Int[] | Int;
  checklimit_lt?: Int;
  checklimit_lte?: Int;
  checklimit_gt?: Int;
  checklimit_gte?: Int;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface BraceletCreateInput {
  code: String;
  group: GroupCreateOneWithoutBraceletsInput;
  checks?: CheckCreateManyWithoutBraceletInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface GroupCreateWithoutOwnerInput {
  code: String;
  bracelets?: BraceletCreateManyWithoutGroupInput;
  activation?: ActivationCreateOneWithoutGroupsInput;
}

export interface ProductUpdateManyDataInput {
  name?: String;
  description?: String;
  checklimit?: Int;
}

export interface ProductCreateWithoutCheckpointInput {
  name: String;
  description: String;
  activations?: ActivationCreateManyWithoutProductsInput;
  checklimit?: Int;
}

export interface ActivationUpsertWithWhereUniqueWithoutOwnerInput {
  where: ActivationWhereUniqueInput;
  update: ActivationUpdateWithoutOwnerDataInput;
  create: ActivationCreateWithoutOwnerInput;
}

export interface ActivationCreateWithoutOwnerInput {
  groups?: GroupCreateManyWithoutActivationInput;
  products?: ProductCreateManyWithoutActivationsInput;
}

export interface ActivationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ActivationScalarWhereInput[] | ActivationScalarWhereInput;
  OR?: ActivationScalarWhereInput[] | ActivationScalarWhereInput;
  NOT?: ActivationScalarWhereInput[] | ActivationScalarWhereInput;
}

export interface BraceletCreateWithoutChecksInput {
  code: String;
  group: GroupCreateOneWithoutBraceletsInput;
}

export interface UserUpsertWithoutCreatedGroupsInput {
  update: UserUpdateWithoutCreatedGroupsDataInput;
  create: UserCreateWithoutCreatedGroupsInput;
}

export interface UserCreateInput {
  username: String;
  password: String;
  createdGroups?: GroupCreateManyWithoutOwnerInput;
  activatedGroups?: ActivationCreateManyWithoutOwnerInput;
}

export interface GroupUpsertWithWhereUniqueWithoutActivationInput {
  where: GroupWhereUniqueInput;
  update: GroupUpdateWithoutActivationDataInput;
  create: GroupCreateWithoutActivationInput;
}

export interface CheckCreateInput {
  timestamp: DateTimeInput;
  bracelet: BraceletCreateOneWithoutChecksInput;
  checkpoint: CheckpointCreateOneWithoutChecksInput;
}

export interface GroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  AND?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  OR?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  NOT?: GroupScalarWhereInput[] | GroupScalarWhereInput;
}

export interface CheckCreateWithoutBraceletInput {
  timestamp: DateTimeInput;
  checkpoint: CheckpointCreateOneWithoutChecksInput;
}

export interface ProductUpsertWithWhereUniqueWithoutCheckpointInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCheckpointDataInput;
  create: ProductCreateWithoutCheckpointInput;
}

export interface ActivationUpsertWithWhereUniqueWithoutProductsInput {
  where: ActivationWhereUniqueInput;
  update: ActivationUpdateWithoutProductsDataInput;
  create: ActivationCreateWithoutProductsInput;
}

export interface GroupUpdateManyDataInput {
  code?: String;
}

export interface GroupUpdateManyWithWhereNestedInput {
  where: GroupScalarWhereInput;
  data: GroupUpdateManyDataInput;
}

export interface GroupCreateWithoutActivationInput {
  owner: UserCreateOneWithoutCreatedGroupsInput;
  code: String;
  bracelets?: BraceletCreateManyWithoutGroupInput;
}

export interface ActivationCreateInput {
  owner: UserCreateOneWithoutActivatedGroupsInput;
  groups?: GroupCreateManyWithoutActivationInput;
  products?: ProductCreateManyWithoutActivationsInput;
}

export interface GroupCreateInput {
  owner: UserCreateOneWithoutCreatedGroupsInput;
  code: String;
  bracelets?: BraceletCreateManyWithoutGroupInput;
  activation?: ActivationCreateOneWithoutGroupsInput;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GroupWhereInput;
  AND?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  OR?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  NOT?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
}

export interface CheckpointCreateWithoutProductsInput {
  name: String;
  checks?: CheckCreateManyWithoutCheckpointInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBracelet {
  count: Int;
}

export interface AggregateBraceletPromise
  extends Promise<AggregateBracelet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBraceletSubscription
  extends Promise<AsyncIterator<AggregateBracelet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Checkpoint {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface CheckpointPromise extends Promise<Checkpoint>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  checks: <T = FragmentableArray<Check>>(
    args?: {
      where?: CheckWhereInput;
      orderBy?: CheckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CheckpointSubscription
  extends Promise<AsyncIterator<Checkpoint>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  checks: <T = Promise<AsyncIterator<CheckSubscription>>>(
    args?: {
      where?: CheckWhereInput;
      orderBy?: CheckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BraceletEdge {
  cursor: String;
}

export interface BraceletEdgePromise
  extends Promise<BraceletEdge>,
    Fragmentable {
  node: <T = BraceletPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BraceletEdgeSubscription
  extends Promise<AsyncIterator<BraceletEdge>>,
    Fragmentable {
  node: <T = BraceletSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Check {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  timestamp: DateTimeOutput;
}

export interface CheckPromise extends Promise<Check>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  timestamp: () => Promise<DateTimeOutput>;
  bracelet: <T = BraceletPromise>() => T;
  checkpoint: <T = CheckpointPromise>() => T;
}

export interface CheckSubscription
  extends Promise<AsyncIterator<Check>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  timestamp: () => Promise<AsyncIterator<DateTimeOutput>>;
  bracelet: <T = BraceletSubscription>() => T;
  checkpoint: <T = CheckpointSubscription>() => T;
}

export interface BraceletConnection {}

export interface BraceletConnectionPromise
  extends Promise<BraceletConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BraceletEdge>>() => T;
  aggregate: <T = AggregateBraceletPromise>() => T;
}

export interface BraceletConnectionSubscription
  extends Promise<AsyncIterator<BraceletConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BraceletEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBraceletSubscription>() => T;
}

export interface Group {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  code: () => Promise<String>;
  bracelets: <T = FragmentableArray<Bracelet>>(
    args?: {
      where?: BraceletWhereInput;
      orderBy?: BraceletOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  activation: <T = ActivationPromise>() => T;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  code: () => Promise<AsyncIterator<String>>;
  bracelets: <T = Promise<AsyncIterator<BraceletSubscription>>>(
    args?: {
      where?: BraceletWhereInput;
      orderBy?: BraceletOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  activation: <T = ActivationSubscription>() => T;
}

export interface AggregateActivation {
  count: Int;
}

export interface AggregateActivationPromise
  extends Promise<AggregateActivation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivationSubscription
  extends Promise<AsyncIterator<AggregateActivation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Activation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ActivationPromise extends Promise<Activation>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  groups: <T = FragmentableArray<Group>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  products: <T = FragmentableArray<Product>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ActivationSubscription
  extends Promise<AsyncIterator<Activation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  groups: <T = Promise<AsyncIterator<GroupSubscription>>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ActivationSubscriptionPayloadPromise
  extends Promise<ActivationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivationPreviousValuesPromise>() => T;
}

export interface ActivationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivationPreviousValuesSubscription>() => T;
}

export interface ProductConnection {}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ActivationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ActivationPreviousValuesPromise
  extends Promise<ActivationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActivationPreviousValuesSubscription
  extends Promise<AsyncIterator<ActivationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GroupEdge {
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivationEdge {
  cursor: String;
}

export interface ActivationEdgePromise
  extends Promise<ActivationEdge>,
    Fragmentable {
  node: <T = ActivationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivationEdgeSubscription
  extends Promise<AsyncIterator<ActivationEdge>>,
    Fragmentable {
  node: <T = ActivationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCheckpoint {
  count: Int;
}

export interface AggregateCheckpointPromise
  extends Promise<AggregateCheckpoint>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCheckpointSubscription
  extends Promise<AsyncIterator<AggregateCheckpoint>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BraceletSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BraceletSubscriptionPayloadPromise
  extends Promise<BraceletSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BraceletPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BraceletPreviousValuesPromise>() => T;
}

export interface BraceletSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BraceletSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BraceletSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BraceletPreviousValuesSubscription>() => T;
}

export interface CheckpointConnection {}

export interface CheckpointConnectionPromise
  extends Promise<CheckpointConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CheckpointEdge>>() => T;
  aggregate: <T = AggregateCheckpointPromise>() => T;
}

export interface CheckpointConnectionSubscription
  extends Promise<AsyncIterator<CheckpointConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CheckpointEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCheckpointSubscription>() => T;
}

export interface BraceletPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface BraceletPreviousValuesPromise
  extends Promise<BraceletPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface BraceletPreviousValuesSubscription
  extends Promise<AsyncIterator<BraceletPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCheck {
  count: Int;
}

export interface AggregateCheckPromise
  extends Promise<AggregateCheck>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCheckSubscription
  extends Promise<AsyncIterator<AggregateCheck>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  checklimit?: Int;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  checklimit: () => Promise<Int>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  checklimit: () => Promise<AsyncIterator<Int>>;
}

export interface CheckConnection {}

export interface CheckConnectionPromise
  extends Promise<CheckConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CheckEdge>>() => T;
  aggregate: <T = AggregateCheckPromise>() => T;
}

export interface CheckConnectionSubscription
  extends Promise<AsyncIterator<CheckConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CheckEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCheckSubscription>() => T;
}

export interface CheckSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CheckSubscriptionPayloadPromise
  extends Promise<CheckSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CheckPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CheckPreviousValuesPromise>() => T;
}

export interface CheckSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CheckSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CheckSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CheckPreviousValuesSubscription>() => T;
}

export interface Product {
  id: ID_Output;
  name: String;
  description: String;
  checklimit?: Int;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  activations: <T = FragmentableArray<Activation>>(
    args?: {
      where?: ActivationWhereInput;
      orderBy?: ActivationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  checkpoint: <T = CheckpointPromise>() => T;
  checklimit: () => Promise<Int>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  activations: <T = Promise<AsyncIterator<ActivationSubscription>>>(
    args?: {
      where?: ActivationWhereInput;
      orderBy?: ActivationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  checkpoint: <T = CheckpointSubscription>() => T;
  checklimit: () => Promise<AsyncIterator<Int>>;
}

export interface CheckPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  timestamp: DateTimeOutput;
}

export interface CheckPreviousValuesPromise
  extends Promise<CheckPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  timestamp: () => Promise<DateTimeOutput>;
}

export interface CheckPreviousValuesSubscription
  extends Promise<AsyncIterator<CheckPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  timestamp: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductEdge {
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupConnection {}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface CheckpointSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CheckpointSubscriptionPayloadPromise
  extends Promise<CheckpointSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CheckpointPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CheckpointPreviousValuesPromise>() => T;
}

export interface CheckpointSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CheckpointSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CheckpointSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CheckpointPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  createdGroups: <T = FragmentableArray<Group>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  activatedGroups: <T = FragmentableArray<Activation>>(
    args?: {
      where?: ActivationWhereInput;
      orderBy?: ActivationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  createdGroups: <T = Promise<AsyncIterator<GroupSubscription>>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  activatedGroups: <T = Promise<AsyncIterator<ActivationSubscription>>>(
    args?: {
      where?: ActivationWhereInput;
      orderBy?: ActivationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Bracelet {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface BraceletPromise extends Promise<Bracelet>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
  group: <T = GroupPromise>() => T;
  checks: <T = FragmentableArray<Check>>(
    args?: {
      where?: CheckWhereInput;
      orderBy?: CheckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BraceletSubscription
  extends Promise<AsyncIterator<Bracelet>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
  group: <T = GroupSubscription>() => T;
  checks: <T = Promise<AsyncIterator<CheckSubscription>>>(
    args?: {
      where?: CheckWhereInput;
      orderBy?: CheckOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GroupPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface ActivationConnection {}

export interface ActivationConnectionPromise
  extends Promise<ActivationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivationEdge>>() => T;
  aggregate: <T = AggregateActivationPromise>() => T;
}

export interface ActivationConnectionSubscription
  extends Promise<AsyncIterator<ActivationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivationSubscription>() => T;
}

export interface CheckpointPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface CheckpointPreviousValuesPromise
  extends Promise<CheckpointPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface CheckpointPreviousValuesSubscription
  extends Promise<AsyncIterator<CheckpointPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CheckEdge {
  cursor: String;
}

export interface CheckEdgePromise extends Promise<CheckEdge>, Fragmentable {
  node: <T = CheckPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CheckEdgeSubscription
  extends Promise<AsyncIterator<CheckEdge>>,
    Fragmentable {
  node: <T = CheckSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CheckpointEdge {
  cursor: String;
}

export interface CheckpointEdgePromise
  extends Promise<CheckpointEdge>,
    Fragmentable {
  node: <T = CheckpointPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CheckpointEdgeSubscription
  extends Promise<AsyncIterator<CheckpointEdge>>,
    Fragmentable {
  node: <T = CheckpointSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Activation",
    embedded: false
  },
  {
    name: "Bracelet",
    embedded: false
  },
  {
    name: "Check",
    embedded: false
  },
  {
    name: "Checkpoint",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
